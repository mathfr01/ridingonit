<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="I'm riding on it!">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    <title>I'm riding on it!</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info { position: absolute; top: 10px; text-align: center; z-index: 100; color: white; background-color:black; padding:5px; border-radius:5px; }
        #dashboard {
            display: none; 
            position:absolute; 
            top:1px; left:50%; 
            transform: translateX(-50%); 
            text-align:center; 
            z-index:10; 
            min-width:350px; 
            max-height:10%; 
            color:white; 
            padding:3px; 
            border-radius:15px;
            font-size:4vw;
            }
        #chances {margin:5px;}
        #collisions {margin:5px;  min-width:4vw; min-height:3vw; border-radius:3vw; background-color: rgba(0,255,0,0.5); padding:7px; display: inline-block; color:black;}
        #totalpointscontained { margin:5px; min-height:2vw; vertical-align: middle; padding:7px; border-radius:3px; background-color: rgba(255,255,255,0.5); display: inline-block; color:black;}
        #nuggetscontained { margin:5px; min-height:2vw; vertical-align: middle; padding:7px; border-radius:3px; background-color: rgba(255,255,255,0.5); display: inline-block; color:black;}
        #totalPoints {color:black;}
        #Announcement {display: block; position:absolute; width:50%; height:50%; margin-left:25%; bottom:25%; background-color:white; color:darkgray; text-align:center;}
        button{font-size:large;}
        #pauseButton { display: none; position:absolute; top:1px; right:1px; color:white; font-size:3vw; cursor: pointer; }
        #countdown { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 5vw; color: white; background-color: black; padding: 20px; border-radius: 10px; }
   </style>
</head>
<body>

<!-- Add the audio element here -->
<audio id="backgroundAudio" src="sounds/RiverStream.mp3" loop></audio>
<audio id="collisionAudio" src="sounds/collision.mp3"></audio>
<audio id="treasureAudio" src="sounds/treasureFound.mp3"></audio>
<audio id="turnAudio" src="sounds/turn.mp3"></audio>
<audio id="Quote1" src="sounds/61-0429E-The-Uncertain-Sound-_69m-54s-70m-12s_-VGR.mp3"></audio>
<audio id="Quote2" src="sounds/61-0429E-The-Uncertain-Sound-_91m-7s-91m-20s_-VGR.mp3"></audio>
<audio id="Quote3" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_86m-37s-87m-3s_-VGR.mp3"></audio>
<audio id="Quote4" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_91m-8s-91m-26s_-VGR.mp3"></audio>
<audio id="Quote5" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_92m-5s-92m-45s_-VGR.mp3"></audio>
<audio id="Quote6" src="sounds/63-0608-Conferences-_98m-14s-98m-39s_-VGR.mp3"></audio>
<audio id="Quote7" src="sounds/63-0608-Conferences-_98m-57s-99m-21s_-VGR.mp3"></audio>
<audio id="Quote8" src="sounds/64-0206E-Gods-Provided-Way-For-This-Day-_39m-28s-39m-46s_-VGR.mp3"></audio>

<script>
    let simpleNoise = `
  float N (vec2 st) { // https://thebookofshaders.com/10/
      return fract( sin( dot( st.xy, vec2(12.9898,78.233 ) ) ) *  43758.5453123);
  }
  
  float smoothNoise( vec2 ip ){ 
      vec2 lv = fract( ip );
    vec2 id = floor( ip );
    
    lv = lv * lv * ( 3. - 2. * lv );
    
    float bl = N( id );
    float br = N( id + vec2( 1, 0 ));
    float b = mix( bl, br, lv.x );
    
    float tl = N( id + vec2( 0, 1 ));
    float tr = N( id + vec2( 1, 1 ));
    float t = mix( tl, tr, lv.x );
    
    return mix( b, t, lv.y );
  }
`;
</script>

<script type="importmap">
  {
    "imports": {
        "three": "./three.module.js",
        "three/addons/": "./addons/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { Sky } from 'three/addons/objects/Sky.js';
import { Water } from 'three/addons/objects/Water.js';

    console.log("Script module parsing started. Version 13 (Full Integration Test).");

    let scene, camera, renderer;
    let character;
    let sky, sun;
    let water1, water2; // For dual plane water looping
    let fillLight, directionalLight;
    let obstacles = [];
    let nuggets = [];
    let trees = [];
    let fishes = [];
    let grasss = [];
    let forestMesh1, forestMesh2; // For dual plane terrain looping
    const forestLength = 600; // Length of one terrain/water segment
    const waterLength = 600;  // Length of one water segment

    let lanePositions = [-2, 0, 2];
    let currentLane = 1;
    let speed = 0.1;
    let chances = 3;
    const SUBMERGE_AMOUNT = 0.3; // Adjusted for more submersion
    let CharacterInitialY = 0;
    let characterBaseYOffset = 0;

    let targetCharacterRotationY = Math.PI;
    let targetCharacterRotationZ = 0;
    const LEAN_ANGLE = Math.PI / 15;
    let rotationSpeed = 0.1;

    let treasures = 0;
    const clock = new THREE.Clock();
    let QuoteNumber;
    let RandomQuote = null;
    let totalPoints = 0;
    let isTransitioning = false;
    let targetLane = 1;
    let isPaused = false;

    let shakeDuration = 0;
    let shakeTime = 0;

    let lastTime = 0;
    const fps = 30;
    const interval = 1000 / fps;

    let gameReadyToStartByUser = false;
    let assetsLoaded = false;
    let gameInitialized = false;
    let animationLoopStarted = false;
    let firstAnimateCall = true;
    let waterNormals;
    let currentCountdownInterval = null;
    window.countdownStarted = false;

    const manager = new THREE.LoadingManager();
    manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
        console.log( `LoadingManager: Loading file: ${url}. Loaded ${itemsLoaded} of ${itemsTotal} files.` );
    };
    manager.onLoad = () => {
      console.log('LoadingManager: All assets loaded callback triggered.');
      assetsLoaded = true;

      if (!gameInitialized) {
          console.log('LoadingManager.onLoad: Game not initialized yet. Calling init().');
          init();
          gameInitialized = true;
      } else {
          console.log('LoadingManager.onLoad: Game already initialized. Skipping init().');
      }

      console.log(`LoadingManager.onLoad: Flags - gameReadyToStartByUser: ${gameReadyToStartByUser}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);
      if (gameReadyToStartByUser && gameInitialized && !animationLoopStarted) {
          console.log("LoadingManager.onLoad: Conditions met to start animation.");
          initiateAnimationLoop();
      } else {
          console.log("LoadingManager.onLoad: Conditions NOT met to start animation yet.");
          if (!gameReadyToStartByUser) console.log("Reason: User hasn't clicked start.");
          if (!gameInitialized) console.log("Reason: Game not initialized (should not happen if this far).");
          if (animationLoopStarted) console.log("Reason: Animation loop already started.");
      }
    };
    manager.onError = (url) => {
      console.error('LoadingManager: There was an error loading ' + url);
    };

    const textureLoader = new THREE.TextureLoader(manager);
    const heightMapImage = textureLoader.load('media/HeightMap.jpg',
        () => console.log("Texture media/HeightMap.jpg loaded successfully."),
        undefined,
        (err) => console.error("Error loading media/HeightMap.jpg via TextureLoader:", err)
    );
    const HeightMapTexture = textureLoader.load('media/HeightMapTexture.jpg',
        () => console.log("Texture media/HeightMapTexture.jpg loaded successfully."),
        undefined,
        (err) => console.error("Error loading media/HeightMapTexture.jpg via TextureLoader:", err)
    );
    waterNormals = textureLoader.load('media/waternormals.jpg', function ( texture ) {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        console.log("Texture media/waternormals.jpg for water loaded successfully.");
    }, undefined, (err) => console.error("Error loading media/waternormals.jpg for water:", err));


    function initSky() {
        console.log("initSky function called.");
        sky = new Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);
        sun = new THREE.Vector3();
        const effectController = {
            turbidity: 10, rayleigh: 2, mieCoefficient: 0.005, mieDirectionalG: 0.7,
            elevation: 10, azimuth: 180, exposure: 0.5
        };
        const uniforms = sky.material.uniforms;
        uniforms['turbidity'].value = effectController.turbidity;
        uniforms['rayleigh'].value = effectController.rayleigh;
        uniforms['mieCoefficient'].value = effectController.mieCoefficient;
        uniforms['mieDirectionalG'].value = effectController.mieDirectionalG;
        const phi = THREE.MathUtils.degToRad(90 - effectController.elevation);
        const theta = THREE.MathUtils.degToRad(effectController.azimuth);
        sun.setFromSphericalCoords(1, phi, theta);
        uniforms['sunPosition'].value.copy(sun);
        if(renderer) renderer.toneMappingExposure = effectController.exposure;
        console.log("Sky initialized and added to scene.");
    }
    function addTrees() { console.log("addTrees function called (simplified).");}
    function addGrass(){ console.log("addGrass function called (simplified).");}
    function addFishes() { console.log("addFishes function called (simplified).");}

    let touchStartX = null;
    let touchEndX = null;
    function onTouchStart(event) {
        if (!animationLoopStarted || isPaused) return;
        touchStartX = event.touches[0].clientX;
    }
    function onTouchMove(event) {
        if (!animationLoopStarted || isPaused) return;
        touchEndX = event.touches[0].clientX;
    }
    function onTouchEnd() {
        if (!character || !gameReadyToStartByUser || !assetsLoaded || !gameInitialized || !animationLoopStarted || isPaused) return;
        if (touchStartX && touchEndX) {
            const deltaX = touchEndX - touchStartX;
            const turnAudio = document.getElementById('turnAudio');
            if (deltaX > 50) {
                if(turnAudio) turnAudio.play();
                targetLane = Math.min(2, currentLane + 1);
                targetCharacterRotationY = Math.PI - Math.PI / 8;
                targetCharacterRotationZ = -LEAN_ANGLE;
            } else if (deltaX < -50) {
                if(turnAudio) turnAudio.play();
                targetLane = Math.max(0, currentLane - 1);
                targetCharacterRotationY = Math.PI + Math.PI / 8;
                targetCharacterRotationZ = LEAN_ANGLE;
            }
            if (targetLane !== currentLane && character) {
                isTransitioning = true;
                smoothTransition(character.position.x, lanePositions[targetLane], 100, () => {
                    currentLane = targetLane;
                    isTransitioning = false;
                });
            }
        }
        touchStartX = null; touchEndX = null;
    }

    function onKeyDown(event) {
        if (!character || !gameReadyToStartByUser || !assetsLoaded || !gameInitialized || !animationLoopStarted ) {
            if(event.key === 'p' && gameInitialized) togglePause();
            return;
        }
        if (isPaused && event.key !== 'p') return;

        const turnAudio = document.getElementById('turnAudio');
        if (isTransitioning && (event.key === 'ArrowLeft' || event.key === 'a' || event.key === 'ArrowRight' || event.key === 'd')) {
            if ((event.key === 'ArrowLeft' || event.key === 'a')) {
                targetCharacterRotationY = Math.PI + Math.PI / 8;
                targetCharacterRotationZ = LEAN_ANGLE;
            } else if ((event.key === 'ArrowRight' || event.key === 'd')) {
                targetCharacterRotationY = Math.PI - Math.PI / 8;
                targetCharacterRotationZ = -LEAN_ANGLE;
            }
            return;
        }
        if (isTransitioning) return;

        if (event.key === 'ArrowLeft' || event.key === 'a') {
            if(turnAudio) turnAudio.play();
            targetLane = Math.max(0, currentLane - 1);
            targetCharacterRotationY = Math.PI + Math.PI / 8;
            targetCharacterRotationZ = LEAN_ANGLE;
        } else if (event.key === 'ArrowRight' || event.key === 'd') {
            if(turnAudio) turnAudio.play();
            targetLane = Math.min(2, currentLane + 1);
            targetCharacterRotationY = Math.PI - Math.PI / 8;
            targetCharacterRotationZ = -LEAN_ANGLE;
        } else if (event.key === 'p') { togglePause(); }
        else { return; }

        if (targetLane !== currentLane && character) {
            isTransitioning = true;
            smoothTransition(character.position.x, lanePositions[targetLane], 100, () => {
                currentLane = targetLane; isTransitioning = false;
            });
        }
    }

    function smoothTransition(start, end, duration, callback) {
        const startTime = Date.now();
        function animateTransition() {
            const now = Date.now();
            const elapsed = now - startTime;
            const t = Math.min(elapsed / duration, 1);
            if (character) {
                character.position.x = start + (end - start) * t;
            }
            if (t < 1) {
                requestAnimationFrame(animateTransition);
            } else {
                if (callback) callback();
            }
        }
        requestAnimationFrame(animateTransition);
    }
    function getRandomQuoteNumber() { return Math.floor(Math.random() * 8) + 1; }

    function playRandomQuote() {
        if (RandomQuote && !RandomQuote.paused && RandomQuote.currentTime > 0 && RandomQuote.duration > 0 && RandomQuote.currentTime < RandomQuote.duration - 0.1) { // Check if ended or very close to end
            console.log("A quote is already playing.");
            return;
        }
        QuoteNumber = getRandomQuoteNumber();
        RandomQuote = document.getElementById('Quote' + QuoteNumber);
        if (RandomQuote) {
            console.log("Playing quote: ", QuoteNumber);
            RandomQuote.currentTime = 0; // Ensure it plays from the start
            RandomQuote.play().catch(e => console.warn("Quote audio play failed:", e));
        } else {
            console.warn("Could not find Quote audio element for number:", QuoteNumber);
        }
    }

    function triggerCameraShake(duration) { shakeDuration = duration; shakeTime = 0;}
    function applyCameraShake() {
        if (shakeTime < shakeDuration && camera) {
            const shakeAmount = 0.08;
            camera.position.x += (Math.random() - 0.5) * shakeAmount;
            camera.position.y += (Math.random() - 0.5) * shakeAmount;
            shakeTime += 1/fps;
        }
    }
    function updatePoints() {
        if(isPaused || !animationLoopStarted) return;
        totalPoints += 1;
        const totalPointsEl = document.getElementById('totalPoints');
        if(totalPointsEl) totalPointsEl.innerText = totalPoints;
        IncreaseSpeed();
    }
    function IncreaseSpeed() {
        if (totalPoints % 1000 === 0 && totalPoints > 0) {
            speed = Math.min(speed + 0.02, 0.5);
            console.log("Speed increased to:", speed);
        }
    }

    function animateWater() {
        if (water1 && water1.material.uniforms && water1.material.uniforms['time']) {
            water1.material.uniforms['time'].value += 1.0 / 60.0;
        }
        if (water2 && water2.material.uniforms && water2.material.uniforms['time']) {
            water2.material.uniforms['time'].value += 1.0 / 60.0;
        }
    }

    function checkCollisions() {
        if (!character || !gameInitialized || isPaused || !animationLoopStarted) return;

        const collisionAudio = document.getElementById('collisionAudio');
        const treasureAudio = document.getElementById('treasureAudio');
        const chancesEl = document.getElementById('chances');
        const treasuresFoundEl = document.getElementById('treasuresFound');
        const collisionsDiv = document.getElementById('collisions');

        // Obstacle collisions
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obstacle = obstacles[i];
            if (character.position.distanceTo(obstacle.position) < 0.65) {
                console.log("Collision with obstacle!");
                if(collisionAudio) collisionAudio.play();

                chances--;
                if(chancesEl) chancesEl.innerText = chances;

                if(collisionsDiv){
                    if (chances === 2) collisionsDiv.style.backgroundColor = 'rgba(236,255,0,0.5)';
                    else if (chances === 1) collisionsDiv.style.backgroundColor = 'rgba(255,125,0,0.5)';
                    else if (chances <= 0) collisionsDiv.style.backgroundColor = 'rgba(255,0,0,0.5)';
                    else collisionsDiv.style.backgroundColor = 'rgba(0,255,0,0.5)';
                }

                obstacle.position.z = character.position.z - 150 - Math.random() * 50;
                obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];

                triggerCameraShake(0.5);

                if (chances <= 0) {
                    console.log("Game Over!");
                    const backgroundAudio = document.getElementById('backgroundAudio');
                    if(backgroundAudio) backgroundAudio.pause();
                    alert('Game Over!\nScore: ' + totalPoints + '\nTotal nuggets: ' + treasures + '\nPress OK to restart.');
                    window.location.reload();
                    return;
                }
            }
        }

        // Nugget collisions
        for (let i = nuggets.length - 1; i >= 0; i--) {
            const nugget = nuggets[i];
            if (character.position.distanceTo(nugget.position) < 0.7) { // Adjusted nugget collision radius if needed due to scale
                console.log("Collected nugget!");
                if(treasureAudio) treasureAudio.play();
                playRandomQuote();

                treasures++;
                chances++;

                if(treasuresFoundEl) treasuresFoundEl.innerText = treasures;
                if(chancesEl) chancesEl.innerText = chances;

                if(collisionsDiv){
                    if (chances === 2) collisionsDiv.style.backgroundColor = 'rgba(236,255,0,0.5)';
                    else if (chances === 1) collisionsDiv.style.backgroundColor = 'rgba(255,125,0,0.5)';
                    else if (chances <= 0) collisionsDiv.style.backgroundColor = 'rgba(255,0,0,0.5)';
                    else collisionsDiv.style.backgroundColor = 'rgba(0,255,0,0.5)';
                }
                nugget.position.z = character.position.z - 150 - Math.random() * 50;
                nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
            }
        }
    }

    function init() {
        console.log("init function started.");
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000000);
        camera.position.set(0, 2.0, 4.0);
        camera.lookAt(0, 0.5, 0);
        console.log("Initial Camera Position:", camera.position);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5;
        document.body.appendChild(renderer.domElement);

        initSky();

        fillLight = new THREE.HemisphereLight(0x8dc1de, 0x00668d, 1.5);
        scene.add(fillLight);
        directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);
        renderer.shadowMap.enabled = true;

        console.log("Attempting to add terrain planes.");
        if (heightMapImage.image && HeightMapTexture && heightMapImage.image.complete && heightMapImage.image.naturalHeight !== 0) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const context = canvas.getContext('2d');
            context.drawImage(heightMapImage.image, 0, 0, size, size);
            const heightData = context.getImageData(0, 0, size, size).data;
            const planeGeometry = new THREE.PlaneGeometry(300, forestLength, size - 1, size - 1);
            for (let i = 0; i < planeGeometry.attributes.position.count; i++) {
                const xVal = i % size; const yVal = Math.floor(i / size);
                const height = heightData[(yVal * size + xVal) * 4] / 255 * 10;
                planeGeometry.attributes.position.setZ(i, height);
            }
            planeGeometry.computeVertexNormals();
            const planeMaterial = new THREE.MeshStandardMaterial({ map: HeightMapTexture });

            forestMesh1 = new THREE.Mesh(planeGeometry, planeMaterial);
            forestMesh1.rotation.x = -Math.PI / 2;
            forestMesh1.position.y = -0.5;
            forestMesh1.position.z = -forestLength / 2 + 50;
            forestMesh1.receiveShadow = true;
            scene.add(forestMesh1);

            forestMesh2 = new THREE.Mesh(planeGeometry.clone(), planeMaterial.clone());
            forestMesh2.rotation.x = -Math.PI / 2;
            forestMesh2.position.y = -0.5;
            forestMesh2.position.z = forestMesh1.position.z - forestLength;
            forestMesh2.receiveShadow = true;
            scene.add(forestMesh2);
            console.log("Dual terrain planes added.");
        } else {
            console.warn("Terrain textures not ready, using placeholder flat terrain.");
            const placeholderGeo = new THREE.PlaneGeometry(300, forestLength);
            const placeholderMat = new THREE.MeshStandardMaterial({ color: 0x335522 });
            forestMesh1 = new THREE.Mesh(placeholderGeo, placeholderMat);
            forestMesh1.rotation.x = -Math.PI / 2; forestMesh1.position.y = -0.5;
            forestMesh1.position.z = -forestLength/2 + 50; scene.add(forestMesh1);
            forestMesh2 = new THREE.Mesh(placeholderGeo.clone(), placeholderMat.clone());
            forestMesh2.rotation.x = -Math.PI/2; forestMesh2.position.y = -0.5;
            forestMesh2.position.z = forestMesh1.position.z - forestLength; scene.add(forestMesh2);
            console.log("Placeholder terrain planes added.");
        }

        console.log("Attempting to add water planes. Water Normals loaded:", waterNormals && waterNormals.image && waterNormals.image.complete);
        if (Water && waterNormals && waterNormals.image && waterNormals.image.complete && waterNormals.image.naturalHeight !== 0) {
            const waterPlaneGeometry = new THREE.PlaneGeometry(14, waterLength, 10, 50);
            let sunDir = new THREE.Vector3(0,1,0);
            if (sky && sky.material.uniforms.sunPosition) {
                sunDir.copy(sky.material.uniforms.sunPosition.value);
                console.log("Water using sunDirection from sky:", sunDir);
            } else if (directionalLight) {
                sunDir.copy(directionalLight.position).normalize();
                console.log("Water using sunDirection from directionalLight:", sunDir);
            } else {
                console.warn("Water: Neither sky nor directionalLight sunPosition available, using default sunDir.");
            }

            const waterOptions = {
                textureWidth: 512, textureHeight: 512, waterNormals: waterNormals,
                sunDirection: sunDir, sunColor: 0xffffff,
                waterColor: 0x00ccff, // Bright cyan for testing
                distortionScale: 2.0,
                fog: false,
                alpha: 1.0, // Fully opaque for testing
                scale: 4
            };
            water1 = new Water(waterPlaneGeometry, waterOptions);
            water1.rotation.x = -Math.PI / 2;
            water1.position.y = -0.15; // Raised water level for testing
            water1.position.z = -waterLength / 2 + 50;
            scene.add(water1);

            water2 = new Water(waterPlaneGeometry.clone(), waterOptions);
            water2.rotation.x = -Math.PI / 2;
            water2.position.y = -0.15; // Raised water level for testing
            water2.position.z = water1.position.z - waterLength;
            scene.add(water2);
            console.log("Dual water planes added at Y:", water1.position.y);
        } else {
            let logMessage = "Water not created. Reasons: ";
            if (!Water) logMessage += "Water class not found. ";
            if (!waterNormals) logMessage += "waterNormals variable not defined. ";
            if (waterNormals && !waterNormals.image) logMessage += "waterNormals.image not defined. ";
            if (waterNormals && waterNormals.image && !waterNormals.image.complete) logMessage += "waterNormals.image not complete. ";
            if (waterNormals && waterNormals.image && waterNormals.image.complete && waterNormals.image.naturalHeight === 0) logMessage += "waterNormals.image has zero height. ";
            console.warn(logMessage);
        }

        addCharacter();
        addTrees(); addGrass(); addFishes();

        const dracoLoader = new DRACOLoader(manager);
        dracoLoader.setDecoderPath( 'three/addons/loaders/draco/' );
        const gltfLoader = new GLTFLoader(manager);
        gltfLoader.setDRACOLoader( dracoLoader );

        gltfLoader.load('3Dmodels/rock.glb', (gltf) => {
            console.log("Rock model loaded.");
            for (let i = 0; i < 15; i++) {
                const obstacle = gltf.scene.clone();
                obstacle.scale.set(0.15,0.15,0.15);
                obstacle.position.set(lanePositions[Math.floor(Math.random() * 3)], -0.15, -20 - i * 20); // Lowered rocks
                obstacle.traverse(node => { if (node.isMesh) node.castShadow = true; });
                obstacles.push(obstacle);
                scene.add(obstacle);
            }
        }, undefined, (error)=>console.error("Error loading rock.glb", error));

        gltfLoader.load('3Dmodels/gold_nugget.glb', (gltf) => {
            console.log("Gold nugget model loaded.");
            for (let i = 0; i < 10; i++) {
                const nugget = gltf.scene.clone();
                const scale = 5.0; // INCREASED NUGGET SCALE SIGNIFICANTLY
                nugget.scale.set(scale, scale, scale);
                nugget.position.set(
                    lanePositions[Math.floor(Math.random() * 3)],
                    0.1, // Adjusted Y for nuggets
                    -25 - i * 30 - Math.random() * 10
                );
                console.log("Nugget ["+i+"]: added at X:", nugget.position.x, "Y:", nugget.position.y, "Z:", nugget.position.z);
                nugget.traverse(node => { if (node.isMesh) node.castShadow = true; });
                nuggets.push(nugget);
                scene.add(nugget);
            }
        }, undefined, (error) => console.error("Error loading gold_nugget.glb", error));

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('touchstart', onTouchStart);
        document.addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);
        console.log("init function completed.");
    }

    function addCharacter(){
        console.log("addCharacter function called.");
        const dracoLoader = new DRACOLoader(manager);
        dracoLoader.setDecoderPath( 'three/addons/loaders/draco/' );
        const loader4 = new GLTFLoader(manager);
        loader4.setDRACOLoader( dracoLoader );
        loader4.load('3Dmodels/Lumberjack_on_a_log.glb', function (gltf) {
                console.log("Lumberjack_on_a_log.glb loaded.");
                character = gltf.scene;
                character.scale.set(0.4, 0.4, 0.4);
                const box = new THREE.Box3().setFromObject(character);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                characterBaseYOffset = -(center.y - size.y / 2) - SUBMERGE_AMOUNT;
                character.position.set(lanePositions[currentLane], characterBaseYOffset, -2);
                character.rotation.y = Math.PI;
                character.traverse(node => { if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; }});
                scene.add(character);
                targetLane = currentLane;
                console.log("Character added. BaseYOffset:", characterBaseYOffset, "Final Y:", character.position.y);
            },
            xhr => console.log('Lumberjack model ' + (xhr.loaded / xhr.total * 100) + '% loaded'),
            err => console.error('Error loading Lumberjack_on_a_log.glb:', err)
        );
     }
    function updateCamera() {
        if (!character || !camera) return;
        const desiredX = character.position.x;
        const desiredY = character.position.y + 2.0;
        const desiredZ = character.position.z + 2.5;
        camera.position.x = desiredX;
        camera.position.y = desiredY;
        camera.position.z = desiredZ;
    }

    function animate(currentTime) {
        requestAnimationFrame(animate);
        if (!animationLoopStarted || isPaused) {
            if (isPaused && totalPoints < 10 && document.getElementById('countdown') && document.getElementById('countdown').style.display === 'block') {
                 if(renderer && scene && camera) renderer.render(scene, camera);
            }
            return;
        }
        if (firstAnimateCall) { console.log("animate running."); firstAnimateCall = false; }
        if (!character) { if(renderer && scene && camera) renderer.render(scene, camera); return; }

        character.rotation.y += (targetCharacterRotationY - character.rotation.y) * rotationSpeed;
        character.rotation.z += (targetCharacterRotationZ - character.rotation.z) * rotationSpeed;
        if (!isTransitioning && currentLane === targetLane) {
            const defaultRotationY = Math.PI;
            if (Math.abs(character.rotation.y - defaultRotationY) < rotationSpeed * 0.01 ) character.rotation.y = defaultRotationY;
            targetCharacterRotationY = defaultRotationY;
            if (Math.abs(character.rotation.z) < rotationSpeed * 0.01) character.rotation.z = 0;
            targetCharacterRotationZ = 0;
        }

        const delta = currentTime - lastTime;
        if (delta >= interval) {
            lastTime = currentTime - (delta % interval);
            animateWater();

            if (forestMesh1 && forestMesh2 && character) {
                forestMesh1.position.z += speed;
                forestMesh2.position.z += speed;
                if (forestMesh1.position.z > character.position.z + forestLength / 2 + 20) {
                    forestMesh1.position.z = forestMesh2.position.z - forestLength + speed;
                }
                if (forestMesh2.position.z > character.position.z + forestLength / 2 + 20) {
                    forestMesh2.position.z = forestMesh1.position.z - forestLength + speed;
                }
            }
            if (water1 && water2 && character) {
                water1.position.z += speed;
                water2.position.z += speed;
                if (water1.position.z > character.position.z + waterLength / 2 + 20) {
                    water1.position.z = water2.position.z - waterLength + speed;
                }
                if (water2.position.z > character.position.z + waterLength / 2 + 20) {
                    water2.position.z = water1.position.z - waterLength + speed;
                }
            }

            for (let obstacle of obstacles) {
                 obstacle.position.z += speed;
                if (character && obstacle.position.z > character.position.z + 20 ) {
                    obstacle.position.z = (character.position.z - 130) - Math.random() * 50;
                    obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];
                } else if (!character && obstacle.position.z > 20) {
                     obstacle.position.z = -130 - Math.random() * 50;
                     obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];
                }
            }
            for (let nugget of nuggets) {
                nugget.position.z += speed;
                if (character && nugget.position.z > character.position.z + 20) {
                    nugget.position.z = (character.position.z - 130) - Math.random() * 100;
                    nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
                } else if (!character && nugget.position.z > 20) {
                    nugget.position.z = -130 - Math.random() * 100;
                    nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
                }
            }

            updatePoints();
            updateCamera();
            checkCollisions();
            applyCameraShake();
            if(renderer && scene && camera) renderer.render(scene, camera);
            else console.error("Render call skipped: renderer, scene or camera missing.");

            const Announcement = document.getElementById('Announcement');
            const dashboard = document.getElementById('dashboard');
            const pauseButton = document.getElementById('pauseButton');
            const countdown = document.getElementById('countdown');

            if(totalPoints === 10 && Announcement && Announcement.style.display !== 'none' && !window.countdownStarted){
                window.countdownStarted = true;
                Announcement.style.display = 'none';
                if (!isPaused) togglePause();
                else {
                    if(dashboard) dashboard.style.display = 'block';
                    if(pauseButton) pauseButton.style.display = 'block';
                }
                if(countdown) countdown.style.display = 'block';
                let countdownValue = 3;
                if(countdown) countdown.innerText = countdownValue;

                if (currentCountdownInterval) clearInterval(currentCountdownInterval);
                currentCountdownInterval = setInterval(() => {
                    countdownValue -= 1;
                    if(countdown) {
                        if (countdownValue > 0) {
                            countdown.innerText = countdownValue;
                        } else {
                            clearInterval(currentCountdownInterval);
                            currentCountdownInterval = null;
                            countdown.style.display = 'none';
                            if(isPaused) togglePause();
                            const backgroundAudio = document.getElementById('backgroundAudio');
                            if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed post-countdown:", e));
                        }
                    } else { clearInterval(currentCountdownInterval); currentCountdownInterval = null;}
                }, 1000);
            }
        }
    }

    function initiateAnimationLoop() {
        console.log("initiateAnimationLoop called.");
        console.log(`Flags before starting: gameReadyToStartByUser: ${gameReadyToStartByUser}, assetsLoaded: ${assetsLoaded}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);

        if (!assetsLoaded || !gameInitialized) {
            console.error("Attempted to initiate animation loop, but assets or game not initialized!");
            return;
        }
        if (animationLoopStarted) {
            console.warn("Animation loop already initiated. Ignoring call.");
            if (isPaused) togglePause();
            return;
        }

        const backgroundAudio = document.getElementById('backgroundAudio');
        if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed in initiateAnimationLoop:", e));

        let needsInitialPauseForCountdown = (totalPoints < 10);

        if (needsInitialPauseForCountdown && !isPaused) {
            console.log("initiateAnimationLoop: Initializing first pause for countdown.");
            togglePause();
        } else if (isPaused && !needsInitialPauseForCountdown) {
            console.log("initiateAnimationLoop: Game was paused by user, toggling to resume.");
            togglePause();
        } else if (isPaused && needsInitialPauseForCountdown) {
            console.log("initiateAnimationLoop: Already paused, likely for countdown.");
        }

        firstAnimateCall = true;
        animationLoopStarted = true;

        animate();
        console.log("Animation loop requested. animationLoopStarted set to true.");
    }

    window.startGame = function() {
        console.log("startGame function called by button click.");
        const announcementDiv = document.getElementById('Announcement');
        if(announcementDiv) announcementDiv.style.display = 'none';

        const dashboard = document.getElementById('dashboard');
        const pauseButton = document.getElementById('pauseButton');
        if(dashboard) dashboard.style.display = 'block';
        if(pauseButton) pauseButton.style.display = 'block';

        gameReadyToStartByUser = true;
        console.log(`startGame: Flags - gameReadyToStartByUser: ${gameReadyToStartByUser}, assetsLoaded: ${assetsLoaded}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);

        if (assetsLoaded && gameInitialized && !animationLoopStarted) {
            console.log("startGame: Conditions met to start animation.");
            initiateAnimationLoop();
        } else if (assetsLoaded && gameInitialized && animationLoopStarted) {
            console.log("startGame: Animation loop already started.");
            if(isPaused) {
                console.log("startGame: Was paused, toggling pause to resume.");
                togglePause();
            }
        } else {
            console.log("startGame: Conditions NOT met to start animation immediately.");
            if (!assetsLoaded) console.log("Reason: Assets not yet loaded.");
            if (!gameInitialized) console.log("Reason: Game not yet initialized.");
        }
    }

    function togglePause() {
        isPaused = !isPaused;
        const backgroundAudio = document.getElementById('backgroundAudio');
        const pauseButton = document.getElementById('pauseButton');
        const countdown = document.getElementById('countdown');
        const announcementDiv = document.getElementById('Announcement');

        if (!isPaused) {
            lastTime = performance.now();
            if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed on resume:", e));
            if(pauseButton) pauseButton.innerText = "Pause";
            if(countdown) countdown.style.display = "none";
            if (gameInitialized && assetsLoaded && gameReadyToStartByUser && !animationLoopStarted) {
                console.log("togglePause (resuming): Conditions met, ensuring animation loop starts.");
                initiateAnimationLoop();
            } else if (!animationLoopStarted) {
                 console.log("togglePause (resuming): Animation loop not started, but conditions might not be fully met yet or it's handled by initiateAnimationLoop.");
            }
        } else {
            if(backgroundAudio) backgroundAudio.pause();
            if(pauseButton) pauseButton.innerText = "Resume";
            if(countdown && announcementDiv && (totalPoints >= 10 || (totalPoints < 10 && announcementDiv.style.display === 'none') ) ){
                 countdown.style.display = "block";
                 countdown.style.cursor = "pointer";
                 countdown.innerText = "Game Paused";
                 countdown.onclick = togglePause;
            } else if (countdown && totalPoints === 0 && !gameReadyToStartByUser){
                 // This is initial auto-pause for countdown, text set by interval in animate
            }
        }
        console.log("Game paused state:", isPaused);
     }

    document.getElementById('pauseButton').addEventListener('click', togglePause);
    console.log("End of script module parsing. Event listeners attached. Waiting for asset loading or user interaction.");

</script>


<div id="dashboard">
    <div id="totalpointscontained"><span id="totalPoints">0</span></div>
    <div id="collisions" style="vertical-align: middle;"><span id="chances">3</span></div>
    <div id="nuggetscontained">
        <img src="media/goldnugget.png" style="width:3vw; vertical-align: middle;">
        <span id="treasuresFound" style="color:black; vertical-align: middle;">0</span>
    </div>
</div>

<div id="pauseButton">Pause</div>
<div id="countdown"></div>

<div id="Announcement">
    <img src="media/ridingonittitle.jpeg" style="max-height:50%;">
    <h1>I'm Riding on it!</h1>
    <div onclick="startGame()" style="padding:20px; background-color:gray; border-radius:5px;">
        <span id="Menu" style="font-size:3vw; color:black; cursor:pointer;">Click here to Start the game</span>
    </div>
    <div style="margin-top:10px; font-size:1.5vw;">Let's ride on the river while avoiding the rocks, and collecting the gold nuggets!</div>
    <div><a href="light.html">Click here if you need lower graphic for better game rending.</a></div>
</div>
</body>
</html>
