<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="I'm riding on it!">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    <title>I'm riding on it!</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info { position: absolute; top: 10px; text-align: center; z-index: 100; color: white; background-color:black; padding:5px; border-radius:5px; }
        #dashboard {
            display: none; 
            position:absolute; 
            top:1px; left:50%; 
            transform: translateX(-50%); 
            text-align:center; 
            z-index:10; 
            min-width:350px; 
            max-height:10%; 
            color:white; 
            padding:3px; 
            border-radius:15px;
            font-size:4vw;
            }
        #chances {margin:5px;}
        #collisions {margin:5px;  min-width:4vw; min-height:3vw; border-radius:3vw; background-color: rgba(0,255,0,0.5); padding:7px; display: inline-block; color:black;}
        #totalpointscontained { margin:5px; min-height:2vw; vertical-align: middle; padding:7px; border-radius:3px; background-color: rgba(255,255,255,0.5); display: inline-block; color:black;}
        #nuggetscontained { margin:5px; min-height:2vw; vertical-align: middle; padding:7px; border-radius:3px; background-color: rgba(255,255,255,0.5); display: inline-block; color:black;}
        #totalPoints {color:black;}
        #Announcement {display: block; position:absolute; width:50%; height:50%; margin-left:25%; bottom:25%; background-color:white; color:darkgray; text-align:center;}
        button{font-size:large;}
        #pauseButton { display: none; position:absolute; top:1px; right:1px; color:white; font-size:3vw; cursor: pointer; }
        #countdown { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 5vw; color: white; background-color: black; padding: 20px; border-radius: 10px; }
   </style>
</head>
<body>

<!-- Add the audio element here -->
<audio id="backgroundAudio" src="sounds/RiverStream.mp3" loop></audio>
<audio id="collisionAudio" src="sounds/collision.mp3"></audio>
<audio id="treasureAudio" src="sounds/treasureFound.mp3"></audio>
<audio id="turnAudio" src="sounds/turn.mp3"></audio>
<audio id="Quote1" src="sounds/61-0429E-The-Uncertain-Sound-_69m-54s-70m-12s_-VGR.mp3"></audio>
<audio id="Quote2" src="sounds/61-0429E-The-Uncertain-Sound-_91m-7s-91m-20s_-VGR.mp3"></audio>
<audio id="Quote3" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_86m-37s-87m-3s_-VGR.mp3"></audio>
<audio id="Quote4" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_91m-8s-91m-26s_-VGR.mp3"></audio>
<audio id="Quote5" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_92m-5s-92m-45s_-VGR.mp3"></audio>
<audio id="Quote6" src="sounds/63-0608-Conferences-_98m-14s-98m-39s_-VGR.mp3"></audio>
<audio id="Quote7" src="sounds/63-0608-Conferences-_98m-57s-99m-21s_-VGR.mp3"></audio>
<audio id="Quote8" src="sounds/64-0206E-Gods-Provided-Way-For-This-Day-_39m-28s-39m-46s_-VGR.mp3"></audio>

<script>
    let simpleNoise = `
  float N (vec2 st) { // https://thebookofshaders.com/10/
      return fract( sin( dot( st.xy, vec2(12.9898,78.233 ) ) ) *  43758.5453123);
  }
  
  float smoothNoise( vec2 ip ){ 
      vec2 lv = fract( ip );
    vec2 id = floor( ip );
    
    lv = lv * lv * ( 3. - 2. * lv );
    
    float bl = N( id );
    float br = N( id + vec2( 1, 0 ));
    float b = mix( bl, br, lv.x );
    
    float tl = N( id + vec2( 0, 1 ));
    float tr = N( id + vec2( 1, 1 ));
    float t = mix( tl, tr, lv.x );
    
    return mix( b, t, lv.y );
  }
`;
</script>

<script type="importmap">
  {
    "imports": {
        "three": "./three.module.js",
        "three/addons/": "./addons/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { Sky } from 'three/addons/objects/Sky.js';
import { Water } from 'three/addons/objects/Water.js';

    console.log("Script module parsing started. Version 13 (Full Integration Test).");

    let scene, camera, renderer, character, sky, sun, water1, water2, fillLight, directionalLight, gltfLoader; 
    let obstacles = [];
    let nuggets = [];
    let trees = [];
    let fishes = []; 
    let grasss = [];
    let leftBankMeshes = [];
    let rightBankMeshes = [];
    let leftForestMesh1, rightForestMesh1, leftForestMesh2, rightForestMesh2; 
    const forestLength = 600; 
    const waterLength = 600;  
    let raycaster; 

    let lanePositions = [-2, 0, 2];
    let currentLane = 1;
    let speed = 0.1;
    let chances = 3;
    const SUBMERGE_AMOUNT = 0.3; 
    let CharacterInitialY = 0;
    let characterBaseYOffset = 0;

    let targetCharacterRotationY = Math.PI;
    let targetCharacterRotationZ = 0;
    const LEAN_ANGLE = Math.PI / 15;
    let rotationSpeed = 0.1;

    let treasures = 0;
    const clock = new THREE.Clock();
    let QuoteNumber;
    let RandomQuote = null;
    let totalPoints = 0;
    let isTransitioning = false;
    let targetLane = 1;
    let isPaused = false;
    let isBoosting = false;
    let originalSpeed = 0; 
    const BOOST_FACTOR = 1.5; 

    let bobbingAngle = 0;
    const BOBBING_STRENGTH = 0.015; 
    const BOBBING_SPEED = 0.05;    

    let isJumping = false;
    let jumpProgress = 0; 
    const JUMP_HEIGHT = 2; 
    const JUMP_DURATION = 60; 
    const JUMP_SQUASH_SCALE_Y = 0.7; 
    const JUMP_SQUASH_SCALE_XZ = 1.1; 
    let originalCharacterScaleY = 0.4; 
    let originalCharacterScaleXZ = 0.4;

    const BANK_SPLASH_DENSITY = 0.5; 
    const BANK_SPLASH_VIEW_LENGTH = 60; 
    let bankSplashGlobalCooldown = { lastBankSplashTime: 0 };


    let shakeDuration = 0;
    let shakeTime = 0;

    let lastTime = 0;
    const fps = 30;
    const interval = 1000 / fps;

    let gameReadyToStartByUser = false;
    let assetsLoaded = false;
    let gameInitialized = false;
    let animationLoopStarted = false;
    let firstAnimateCall = true;
    let waterNormals;
    let currentCountdownInterval = null;
    window.countdownStarted = false;

    const manager = new THREE.LoadingManager();
    manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
        console.log( `LoadingManager: Loading file: ${url}. Loaded ${itemsLoaded} of ${itemsTotal} files.` );
    };
    manager.onLoad = () => {
      console.log('LoadingManager: All assets loaded callback triggered.');
      assetsLoaded = true;

      if (!gameInitialized) {
          console.log('LoadingManager.onLoad: Game not initialized yet. Calling init().');
          init();
          gameInitialized = true;
      } else {
          console.log('LoadingManager.onLoad: Game already initialized. Skipping init().');
      }

      console.log(`LoadingManager.onLoad: Flags - gameReadyToStartByUser: ${gameReadyToStartByUser}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);
      if (gameReadyToStartByUser && gameInitialized && !animationLoopStarted) {
          console.log("LoadingManager.onLoad: Conditions met to start animation.");
          initiateAnimationLoop();
      } else {
          console.log("LoadingManager.onLoad: Conditions NOT met to start animation yet.");
          if (!gameReadyToStartByUser) console.log("Reason: User hasn't clicked start.");
          if (!gameInitialized) console.log("Reason: Game not initialized (should not happen if this far).");
          if (animationLoopStarted) console.log("Reason: Animation loop already started.");
      }
    };
    manager.onError = (url) => {
      console.error('LoadingManager: There was an error loading ' + url);
    };

    const textureLoader = new THREE.TextureLoader(manager);
    const heightMapImage = textureLoader.load('media/HeightMap.jpg',
        () => console.log("Texture media/HeightMap.jpg loaded successfully."),
        undefined,
        (err) => console.error("Error loading media/HeightMap.jpg via TextureLoader:", err)
    );
    const HeightMapTexture = textureLoader.load('media/HeightMapTexture.jpg',
        () => console.log("Texture media/HeightMapTexture.jpg loaded successfully."),
        undefined,
        (err) => console.error("Error loading media/HeightMapTexture.jpg via TextureLoader:", err)
    );
    waterNormals = textureLoader.load('media/waternormals.jpg', function ( texture ) {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        console.log("Texture media/waternormals.jpg for water loaded successfully.");
    }, undefined, (err) => console.error("Error loading media/waternormals.jpg for water:", err));

    const grassVertexShader = `
      varying vec2 vUv;
      uniform float time;
      
      ${simpleNoise} 
      
        void main() {
            vUv = uv;
            float t = time * 2.;
            
            vec4 mvPosition = vec4( position, 1.0 );
            #ifdef USE_INSTANCING
                mvPosition = instanceMatrix * mvPosition;
            #endif
            
            float noise = smoothNoise(mvPosition.xz * 0.5 + vec2(0., t));
            noise = pow(noise * 0.5 + 0.5, 2.) * 2.;
            
            float dispPower = 1. - cos( uv.y * 3.1416 * 0.5 );
            float displacement = noise * ( 0.3 * dispPower );
            mvPosition.z -= displacement; 
            
            vec4 modelViewPosition = modelViewMatrix * mvPosition;
            gl_Position = projectionMatrix * modelViewPosition;
        }
    `;

    const grassFragmentShader = `
      varying vec2 vUv;
      
      void main() {
        vec3 baseColor = vec3( 0.41, 1.0, 0.5 ); 
        float clarity = ( vUv.y * 0.875 ) + 0.125;
        gl_FragColor = vec4( baseColor * clarity, 1 );
      }
    `;

    const grassUniforms = {
        time: { value: 0 }
    };

    const leavesMaterial = new THREE.ShaderMaterial({
        vertexShader: grassVertexShader,
        fragmentShader: grassFragmentShader,
        uniforms: grassUniforms,
        side: THREE.DoubleSide
    });

    function createSplashTexture() {
       const canvas = document.createElement('canvas');
       canvas.width = 64;
       canvas.height = 64;
       const context = canvas.getContext('2d');
       
       const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
       gradient.addColorStop(0, 'rgba(255,255,255,0.8)');
       gradient.addColorStop(0.5, 'rgba(200,200,255,0.5)');
       gradient.addColorStop(1, 'rgba(150,150,255,0)');
       
       context.fillStyle = gradient;
       context.fillRect(0, 0, 64, 64);
       
       return new THREE.CanvasTexture(canvas);
    }
    const splashTexture = createSplashTexture();

    let particlePool = [];
    const maxParticles = 200; 
    let particleSystemContainer; 

    function modifyBankVertices(geometry, isLeftBank) {
        console.log('--- Modifying bank START (for sloping) ---');
        console.log('Target Geometry UUID:', geometry.uuid);
        console.log('Parameters: WidthSegs:', geometry.parameters.widthSegments, 'HeightSegs:', geometry.parameters.heightSegments);
        console.log('Is Left Bank:', isLeftBank);
        let minX = Infinity, maxX = -Infinity, minLocalZ = Infinity, maxLocalZ = -Infinity; 
        let modifiedVertexCount = 0;

        const positions = geometry.attributes.position;
        const widthSegments = geometry.parameters.widthSegments; 
        const depthSegments = geometry.parameters.heightSegments; 

        const initialZOffset = 0.05; 
        const maxBankHeight = 1.5;
        const randomHeightFactor = 0.3;
        const outwardPushFactor = 0.5;
        const randomSidewaysFactorBase = 0.05; 
        const randomSidewaysFactorWave = 0.25;

        for (let j = 0; j <= depthSegments; j++) { 
            for (let i = 0; i <= widthSegments; i++) { 
                const index = j * (widthSegments + 1) + i;
                modifiedVertexCount++; 

                let slopeFactor;
                if (isLeftBank) {
                    slopeFactor = (widthSegments - i) / widthSegments; 
                } else {
                    slopeFactor = i / widthSegments;
                }
                slopeFactor = Math.max(0, Math.min(1, slopeFactor));

                let currentLocalZ = initialZOffset + (slopeFactor * maxBankHeight);
                currentLocalZ += (Math.random() - 0.5) * randomHeightFactor;
                positions.setZ(index, currentLocalZ);

                let originalLocalX = positions.getX(index); 
                let currentLocalX = originalLocalX;

                let lengthWiseRandom = (Math.sin(j * 0.15) * randomSidewaysFactorWave + (Math.random() - 0.5) * randomSidewaysFactorBase) * slopeFactor;
                currentLocalX += lengthWiseRandom;

                if (isLeftBank) { 
                    currentLocalX -= slopeFactor * outwardPushFactor; 
                } else { 
                    currentLocalX += slopeFactor * outwardPushFactor; 
                }
                positions.setX(index, currentLocalX);
                
                if (i === 0 || i === widthSegments) { 
                     // console.log(`Bank Debug: j=${j}, i=${i}, slope=${slopeFactor.toFixed(2)}, origX=${originalLocalX.toFixed(2)}, newX=${currentLocalX.toFixed(2)}, newZ=${currentLocalZ.toFixed(2)}`);
                }

                if (currentLocalX < minX) minX = currentLocalX;
                if (currentLocalX > maxX) maxX = currentLocalX;
                if (currentLocalZ < minLocalZ) minLocalZ = currentLocalZ;
                if (currentLocalZ > maxLocalZ) maxLocalZ = currentLocalZ;
            }
        }

        console.log('Total vertices processed for slope:', modifiedVertexCount);
        console.log('Modified vertex ranges (local X):', minX.toFixed(2), 'to', maxX.toFixed(2));
        console.log('Modified vertex ranges (local Z - height):', minLocalZ.toFixed(2), 'to', maxLocalZ.toFixed(2));
        console.log('--- Modifying bank END (for sloping) for:', geometry.uuid, '---');

        if (modifiedVertexCount > 0) {
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
        } else {
            console.warn('No vertices were modified for slope for geometry UUID:', geometry.uuid);
        }
    }

    function initSky() {
        console.log("initSky function called.");
        sky = new Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);
        sun = new THREE.Vector3();
        const effectController = {
            turbidity: 10, rayleigh: 2, mieCoefficient: 0.005, mieDirectionalG: 0.7,
            elevation: 10, azimuth: 180, exposure: 0.5
        };
        const uniforms = sky.material.uniforms;
        uniforms['turbidity'].value = effectController.turbidity;
        uniforms['rayleigh'].value = effectController.rayleigh;
        uniforms['mieCoefficient'].value = effectController.mieCoefficient;
        uniforms['mieDirectionalG'].value = effectController.mieDirectionalG;
        const phi = THREE.MathUtils.degToRad(90 - effectController.elevation);
        const theta = THREE.MathUtils.degToRad(effectController.azimuth);
        sun.setFromSphericalCoords(1, phi, theta);
        uniforms['sunPosition'].value.copy(sun);
        if(renderer) renderer.toneMappingExposure = effectController.exposure;
        console.log("Sky initialized and added to scene.");
    }

    function getTargetTerrainMesh(xPos, zPos) {
        if (!character || !leftForestMesh1 || !leftForestMesh2 || !rightForestMesh1 || !rightForestMesh2) {
            return null;
        }
        const meshesToCheck = [];
        if (xPos < 0) { 
            meshesToCheck.push(leftForestMesh1, leftForestMesh2);
        } else { 
            meshesToCheck.push(rightForestMesh1, rightForestMesh2);
        }
        for (const mesh of meshesToCheck) {
            if (!mesh) continue;
            const halfLength = forestLength / 2;
            const meshMinZ = mesh.position.z - halfLength;
            const meshMaxZ = mesh.position.z + halfLength;
            if (zPos >= meshMinZ && zPos < meshMaxZ) {
                return mesh;
            }
        }
        let closestMesh = null;
        let minDistance = Infinity;
        for (const mesh of meshesToCheck) {
            if (!mesh) continue;
            const dist = Math.abs(zPos - mesh.position.z);
            if (dist < minDistance) {
                minDistance = dist;
                closestMesh = mesh;
            }
        }
        if (closestMesh && minDistance < forestLength / 4) { 
            return closestMesh;
        }
        return null;
    }

    function addTrees() {
        console.log("addTrees function called.");
        if (!gltfLoader) {
            console.error("gltfLoader not initialized in addTrees.");
            return;
        }
        if (!character || !leftForestMesh1 || !rightForestMesh1 || !leftForestMesh2 || !rightForestMesh2) { 
            console.warn("Character or one or more terrain meshes not ready in addTrees. Will retry or skip.");
            if (!character) console.log("addTrees: Character not ready.");
            if (!leftForestMesh1 || !rightForestMesh1 || !leftForestMesh2 || !rightForestMesh2) console.log("addTrees: One or more forest meshes not ready.");
            return;
        }
        if (!raycaster) {
            raycaster = new THREE.Raycaster();
            console.log("Raycaster initialized in addTrees");
        }

        gltfLoader.load(
            '3Dmodels/pine_tree.glb',
            function(gltf) {
                console.log("Pine tree model loaded.");
                const treeModel = gltf.scene;
                const numTrees = 300; 

                for (let i = 0; i < numTrees; i++) {
                    const tree = treeModel.clone();
                    const side = (i % 2 === 0) ? -1 : 1; 
                    
                    let xPos;
                    if (side === -1) { 
                        xPos = -6 - (Math.random() * (144 - 1)); 
                    } else { 
                        xPos = 6 + (Math.random() * (144 - 1));  
                    }
                    
                    const zPos = (character ? character.position.z : 0) - (forestLength / 2) + (Math.random() * forestLength);
                    tree.position.set(xPos, 50, zPos); 

                    const targetTerrainMesh = getTargetTerrainMesh(tree.position.x, tree.position.z);

                    if (targetTerrainMesh) {
                        targetTerrainMesh.updateMatrixWorld(); 
                        const rayOrigin = new THREE.Vector3(tree.position.x, 50, tree.position.z);
                        const rayDirection = new THREE.Vector3(0, -1, 0);
                        raycaster.set(rayOrigin, rayDirection);
                        const intersects = raycaster.intersectObject(targetTerrainMesh, false);

                        if (intersects.length > 0) {
                            tree.position.y = intersects[0].point.y;
                        } else {
                            tree.position.y = -2.1; 
                            console.warn(`Tree raycast FAILED. Tree XZ: (${tree.position.x.toFixed(2)}, ${tree.position.z.toFixed(2)}). Target: ${targetTerrainMesh.uuid}, Target_Z: ${targetTerrainMesh.position.z.toFixed(2)}`);
                        }
                    } else {
                        tree.position.y = -2.1; 
                        console.warn(`No target terrain mesh for tree at XZ: (${tree.position.x.toFixed(2)}, ${tree.position.z.toFixed(2)})`);
                    }

                    const randomScaleBase = 1.5 + Math.random() * 1.0; 
                    const randomScaleY = randomScaleBase * (1.0 + Math.random() * 1.0); 
                    tree.scale.set(randomScaleBase, randomScaleY, randomScaleBase);
                    tree.rotation.y = Math.random() * Math.PI * 2;

                    tree.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true; 
                        }
                    });
                    trees.push(tree);
                    scene.add(tree);
                }
                console.log(trees.length + " trees added to scene.");
            },
            undefined,
            function(error) {
                console.error('An error occurred while loading the pine_tree.glb model:', error);
            }
        );
    }
    function addGrass() {
        console.log("addGrass function called (Instanced Planar Grass).");
        if (!character || !leftForestMesh1 || !rightForestMesh1 || !leftForestMesh2 || !rightForestMesh2) { 
            console.warn("Character or one or more terrain meshes not ready in addGrass, deferring or skipping.");
            return;
        }
        if (!raycaster) { 
            raycaster = new THREE.Raycaster();
            console.log("Raycaster initialized in addGrass");
        }

        const bladeGeometry = new THREE.PlaneGeometry(0.1, 1, 1, 4); 
        bladeGeometry.translate(0, 0.5, 0); 

        const totalPatches = 200; 
        const instancesPerPatch = 150; 

        const dummy = new THREE.Object3D(); 

        for (let i = 0; i < totalPatches; i++) {
            const patchMesh = new THREE.InstancedMesh(bladeGeometry, leavesMaterial, instancesPerPatch);
            patchMesh.castShadow = false; 
            patchMesh.receiveShadow = true;

            const side = (i % 2 === 0) ? -1 : 1;
            let patchX;

            if (side === -1) { 
                patchX = -6 - (2.5 + Math.random() * (144 - 5)); 
            } else { 
                patchX = 6 + (2.5 + Math.random() * (144 - 5));  
            }
            
            const patchZ = (character ? character.position.z : 0) - (forestLength / 2) + (Math.random() * forestLength);
            patchMesh.position.set(patchX, 50, patchZ); 

            const targetTerrainMesh = getTargetTerrainMesh(patchX, patchZ);
            if (targetTerrainMesh) {
                targetTerrainMesh.updateMatrixWorld(); 
                const rayOrigin = new THREE.Vector3(patchMesh.position.x, 50, patchMesh.position.z);
                const rayDirection = new THREE.Vector3(0, -1, 0);
                raycaster.set(rayOrigin, rayDirection);
                const intersects = raycaster.intersectObject(targetTerrainMesh, false);

                if (intersects.length > 0) {
                    patchMesh.position.y = intersects[0].point.y;
                } else {
                    patchMesh.position.y = -2.1; 
                    console.warn("Grass patch raycast FAILED. Patch XZ:", patchMesh.position.x.toFixed(2), patchMesh.position.z.toFixed(2), "Targeted mesh:", targetTerrainMesh.uuid, "Target_Z:", targetTerrainMesh.position.z.toFixed(2));
                }
            } else {
                patchMesh.position.y = -2.1; 
                console.warn("No target terrain mesh for grass patch at XZ:", patchMesh.position.x.toFixed(2), patchMesh.position.z.toFixed(2));
            }
            scene.add(patchMesh);
            grasss.push(patchMesh); 

            for (let j_g = 0; j_g < instancesPerPatch; j_g++) { 
                dummy.position.set(
                    (Math.random() - 0.5) * 5,  
                    0, 
                    (Math.random() - 0.5) * 5
                );
                dummy.scale.setScalar(0.5 + Math.random() * 0.5);
                dummy.rotation.y = Math.random() * Math.PI;
                dummy.updateMatrix();
                patchMesh.setMatrixAt(j_g, dummy.matrix);
            }
            patchMesh.instanceMatrix.needsUpdate = true;
        }
        console.log(grasss.length + " instanced grass patches added to scene.");
    }
    function addFishes() {
        console.log("addFishes function called.");
        if (!gltfLoader) {
            console.error("addFishes: gltfLoader not initialized!");
            return;
        }
        if (!character) {
            console.warn("addFishes: Character not loaded yet, cannot determine initial Z position for fish. Skipping fish adding.");
            return;
        }

        gltfLoader.load( 
            '3Dmodels/fish.glb',
            function(gltf) {
                console.log("Fish model loaded.");
                for (let i = 0; i < 5; i++) { 
                    const fish = gltf.scene.clone();
                    const laneIndex = Math.floor(Math.random() * lanePositions.length);
                    fish.position.set(
                        lanePositions[laneIndex] + (Math.random() - 0.5) * 1.5, 
                        -0.7, 
                        character.position.z - 30 - Math.random() * 100 
                    );

                    fish.scale.set(0.2, 0.2, 0.2);
                    const randomRotationY = Math.random() * Math.PI * 2;
                    fish.rotation.set(0, randomRotationY, 0); 

                    fish.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                        }
                    });
                    fishes.push(fish);
                    scene.add(fish);
                }
                console.log(fishes.length + " fishes added to scene.");
            },
            undefined,
            function(error) {
                console.error('An error occurred while loading the fish.glb model:', error);
            }
        );
    }

    function initParticleSystem() {
       particleSystemContainer = new THREE.Object3D();
       scene.add(particleSystemContainer);

       for (let i = 0; i < maxParticles; i++) {
           const spriteMaterial = new THREE.SpriteMaterial({
               map: splashTexture,
               blending: THREE.AdditiveBlending, 
               transparent: true,
               opacity: 0.8,
               sizeAttenuation: true
           });
           const particle = new THREE.Sprite(spriteMaterial);
           particle.visible = false;
           particle.scale.set(0.2, 0.2, 0.2); 
           particleSystemContainer.add(particle);
           particlePool.push({
               sprite: particle,
               isActive: false,
               life: 0,
               velocity: new THREE.Vector3(),
               gravity: 0.02, 
               initialScale: 0.2,
               maxScale: 0.5,
               scaleSpeed: 0.05
           });
       }
    }

    function emitSplash(position, count = 5, baseVelocity = 0.1, angleOffset = 0, speedMultiplier = 1.0, upwardSpeedBias = 1.0, particleScaleMultiplier = 1.0, lifeMultiplier = 1.0) {
       let activeParticlesBefore = particlePool.filter(p => p.isActive).length;
       if (activeParticlesBefore + count > maxParticles) {
           console.warn(`Particle limit potentially exceeded: Trying to emit ${count}, ${activeParticlesBefore} active, ${maxParticles} pool.`);
       }
       let emittedCount = 0;
       for (let p of particlePool) {
           if (!p.isActive) {
               p.sprite.visible = true;
               p.isActive = true;
               p.life = (1.0 + Math.random() * 0.5) * lifeMultiplier; 
               p.sprite.position.copy(position);
               
               const randomAngleComponent = (Math.random() - 0.5) * (Math.PI / 4); 
               const finalAngle = angleOffset + randomAngleComponent;
               const effectiveBaseVelocity = baseVelocity * speedMultiplier;
               const upwardSpeed = (baseVelocity + Math.random() * baseVelocity) * upwardSpeedBias; 

               p.velocity.set(
                   Math.cos(finalAngle) * effectiveBaseVelocity * (0.5 + Math.random() * 0.5),
                   upwardSpeed,
                   Math.sin(finalAngle) * effectiveBaseVelocity * (0.5 + Math.random() * 0.5)
               );
               p.sprite.scale.set(p.initialScale * particleScaleMultiplier, p.initialScale * particleScaleMultiplier, p.initialScale * particleScaleMultiplier);
               p.sprite.material.opacity = 0.8;

               emittedCount++;
               if (emittedCount >= count) break;
           }
       }
    }

    function updateParticles(delta) { 
       for (let p of particlePool) {
           if (p.isActive) {
               p.life -= delta * 2; 

               if (p.life <= 0) {
                   p.isActive = false;
                   p.sprite.visible = false;
               } else {
                   p.sprite.position.addScaledVector(p.velocity, delta * 20); 
                   p.velocity.y -= p.gravity * delta * 20; 

                   const lifeRatio = Math.max(0, p.life / (1.0 + 0.5)); 
                   p.sprite.material.opacity = Math.max(0, lifeRatio * 0.8);
                   
                   let currentScale = p.sprite.scale.x;
                   currentScale += p.scaleSpeed * delta * 10; 
                   currentScale = Math.min(currentScale, p.maxScale * (p.sprite.scale.x / p.initialScale)); 
                   p.sprite.scale.set(currentScale, currentScale, currentScale);
               }
           }
       }
    }

    let touchStartX = null;
    let touchEndX = null;
    let touchStartY = null;
    let touchEndY = null;

    function onTouchStart(event) {
        if (!animationLoopStarted || isPaused) return;
        touchStartX = event.touches[0].clientX;
        touchStartY = event.touches[0].clientY;
    }

    function onTouchMove(event) {
        if (!animationLoopStarted || isPaused) return;
        touchEndX = event.touches[0].clientX;
        touchEndY = event.touches[0].clientY;
    }

    function onTouchEnd() {
        // Guard clause: Ensure game is in a state that allows touch interactions.
        if (!character || !gameReadyToStartByUser || !assetsLoaded || !gameInitialized || !animationLoopStarted || isPaused) {
            // Reset all touch coordinates if exiting early due to game state.
            touchStartX = null; touchEndX = null; touchStartY = null; touchEndY = null;
            return;
        }

        // Proceed only if all touch start and end coordinates have been recorded.
        // This means a touchstart and (at least one) touchmove event occurred.
        if (touchStartX !== null && touchStartY !== null && touchEndX !== null && touchEndY !== null) {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            // Priority 1: Swipe Up for Jump.
            // Condition: Significant upward movement (negative deltaY) and minimal horizontal movement.
            if (deltaY < -40 && Math.abs(deltaX) < 50) { // Adjusted thresholds for responsiveness
                if (!isJumping && character && animationLoopStarted && !isPaused) { // Check game conditions for jumping
                    isJumping = true;
                    jumpProgress = 0;
                    console.log("Jump initiated by swipe up");
                    // Reset touch coordinates as the jump action is complete.
                    touchStartX = null; touchEndX = null; touchStartY = null; touchEndY = null;
                    return; // Exit after processing the jump action.
                }
            }
            // Priority 2: Swipe Left/Right for Lane Change.
            // Condition: Significant horizontal movement and minimal vertical movement.
            else if (Math.abs(deltaX) > 50 && Math.abs(deltaY) < 50) {
                const turnAudio = document.getElementById('turnAudio');
                if (deltaX > 50) { // Swipe Right
                    if (turnAudio) turnAudio.play();
                    targetLane = Math.min(2, currentLane + 1);
                    targetCharacterRotationY = Math.PI - Math.PI / 8;
                    targetCharacterRotationZ = -LEAN_ANGLE;
                } else { // Swipe Left (deltaX < -50 is implied by Math.abs(deltaX) > 50)
                    if (turnAudio) turnAudio.play();
                    targetLane = Math.max(0, currentLane - 1);
                    targetCharacterRotationY = Math.PI + Math.PI / 8;
                    targetCharacterRotationZ = LEAN_ANGLE;
                }

                if (targetLane !== currentLane && character && !isTransitioning) {
                    isTransitioning = true;
                    const waterY = water1 ? water1.position.y : -0.15;
                    let splashSideOffset = 0.6;
                    let splashPosition = new THREE.Vector3();

                    if (targetLane < currentLane) {
                        splashPosition.set(character.position.x + splashSideOffset, waterY + 0.1, character.position.z);
                    } else {
                        splashPosition.set(character.position.x - splashSideOffset, waterY + 0.1, character.position.z);
                    }
                    emitSplash(splashPosition, 4 + Math.floor(Math.random() * 3), 0.04 + Math.random()*0.03, 0, 1.0, 1.0, 1.0, 1.0);

                    smoothTransition(character.position.x, lanePositions[targetLane], 100, () => {
                        currentLane = targetLane;
                        isTransitioning = false;
                    });
                }
            }
        }

        // Reset all touch coordinates at the end of handling,
        // ensures they are clean for the next touch sequence.
        touchStartX = null; touchEndX = null; touchStartY = null; touchEndY = null;
    }

    function onKeyDown(event) {
        if (!character || !gameReadyToStartByUser || !assetsLoaded || !gameInitialized || !animationLoopStarted ) {
            if(event.key === 'p' && gameInitialized) togglePause();
            return;
        }
        if (isPaused && event.key !== 'p' && event.key.toLowerCase() !== 'w' && event.key !== 'ArrowUp' && event.code !== 'Space') return;
        if (isPaused && (event.key.toLowerCase() === 'w' || event.key === 'ArrowUp' || event.code === 'Space')) return; 

        const turnAudio = document.getElementById('turnAudio');
        if (isTransitioning && (event.key === 'ArrowLeft' || event.key === 'a' || event.key === 'ArrowRight' || event.key === 'd')) {
            if ((event.key === 'ArrowLeft' || event.key === 'a')) {
                targetCharacterRotationY = Math.PI + Math.PI / 8;
                targetCharacterRotationZ = LEAN_ANGLE;
            } else if ((event.key === 'ArrowRight' || event.key === 'd')) {
                targetCharacterRotationY = Math.PI - Math.PI / 8;
                targetCharacterRotationZ = -LEAN_ANGLE;
            }
            return;
        }

        if (event.key === 'ArrowLeft' || event.key === 'a') {
            if (isTransitioning) return; 
            if(turnAudio) turnAudio.play();
            targetLane = Math.max(0, currentLane - 1);
            targetCharacterRotationY = Math.PI + Math.PI / 8;
            targetCharacterRotationZ = LEAN_ANGLE;
        } else if (event.key === 'ArrowRight' || event.key === 'd') {
            if (isTransitioning) return; 
            if(turnAudio) turnAudio.play();
            targetLane = Math.min(2, currentLane + 1);
            targetCharacterRotationY = Math.PI - Math.PI / 8;
            targetCharacterRotationZ = -LEAN_ANGLE;
        } else if (event.key === 'p') { 
            togglePause(); 
            return; 
        } else if ((event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') && !isPaused && animationLoopStarted) {
            if (!isBoosting) {
                originalSpeed = speed;
                speed *= BOOST_FACTOR;
                isBoosting = true;
                console.log("Boost ON. Speed:", speed.toFixed(3));
            }
            return; 
        } else if (event.code === 'Space' && !isJumping && !isPaused && animationLoopStarted && character) {
            isJumping = true;
            jumpProgress = 0;
            console.log("Jump initiated");
            return; 
        }
        else { return; } 

        if (!isTransitioning && targetLane !== currentLane && character) { 
            isTransitioning = true;

            const waterY = water1 ? water1.position.y : -0.15;
            let splashSideOffset = 0.6; 
            let splashPosition = new THREE.Vector3();

            if (targetLane < currentLane) { 
                splashPosition.set(
                    character.position.x + splashSideOffset, 
                    waterY + 0.1, 
                    character.position.z
                );
            } else { 
                splashPosition.set(
                    character.position.x - splashSideOffset, 
                    waterY + 0.1, 
                    character.position.z
                );
            }
            emitSplash(splashPosition, 4 + Math.floor(Math.random() * 3), 0.04 + Math.random()*0.03, 0, 1.0, 1.0, 1.0, 1.0);
            
            smoothTransition(character.position.x, lanePositions[targetLane], 100, () => {
                currentLane = targetLane; isTransitioning = false;
            });
        }
    }

    function smoothTransition(start, end, duration, callback) {
        const startTime = Date.now();
        function animateTransition() {
            const now = Date.now();
            const elapsed = now - startTime;
            const t = Math.min(elapsed / duration, 1);
            if (character) {
                character.position.x = start + (end - start) * t;
            }
            if (t < 1) {
                requestAnimationFrame(animateTransition);
            } else {
                if (callback) callback();
            }
        }
        requestAnimationFrame(animateTransition);
    }
    function getRandomQuoteNumber() { return Math.floor(Math.random() * 8) + 1; }

    function playRandomQuote() {
        if (RandomQuote && !RandomQuote.paused && RandomQuote.currentTime > 0 && RandomQuote.duration > 0 && RandomQuote.currentTime < RandomQuote.duration - 0.1) { 
            console.log("A quote is already playing.");
            return;
        }
        QuoteNumber = getRandomQuoteNumber();
        RandomQuote = document.getElementById('Quote' + QuoteNumber);
        if (RandomQuote) {
            console.log("Playing quote: ", QuoteNumber);
            RandomQuote.currentTime = 0; 
            RandomQuote.play().catch(e => console.warn("Quote audio play failed:", e));
        } else {
            console.warn("Could not find Quote audio element for number:", QuoteNumber);
        }
    }

    function triggerCameraShake(duration) { shakeDuration = duration; shakeTime = 0;}
    function applyCameraShake() {
        if (shakeTime < shakeDuration && camera) {
            const shakeAmount = 0.08;
            camera.position.x += (Math.random() - 0.5) * shakeAmount;
            camera.position.y += (Math.random() - 0.5) * shakeAmount;
            shakeTime += 1/fps;
        }
    }
    function updatePoints() {
        if(isPaused || !animationLoopStarted) return;
        totalPoints += 1;
        const totalPointsEl = document.getElementById('totalPoints');
        if(totalPointsEl) totalPointsEl.innerText = totalPoints;
        IncreaseSpeed();
    }
    function IncreaseSpeed() {
        if (totalPoints % 1000 === 0 && totalPoints > 0) {
            let newBaseSpeed = Math.min((isBoosting ? originalSpeed : speed) + 0.02, 0.5);
            if (isBoosting) {
                originalSpeed = newBaseSpeed;
                speed = originalSpeed * BOOST_FACTOR;
            } else {
                speed = newBaseSpeed;
            }
            console.log("Speed increased by schedule. Base speed now:", (isBoosting ? originalSpeed.toFixed(3) : speed.toFixed(3)), "Current actual speed:", speed.toFixed(3));
        }
    }

    function onKeyUp(event) {
        if ((event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') && isBoosting) {
            speed = originalSpeed;
            isBoosting = false;
            console.log("Boost OFF. Speed restored to:", speed.toFixed(3));
        }
    }

    function animateWater() {
        if (water1 && water1.material.uniforms && water1.material.uniforms['time']) {
            water1.material.uniforms['time'].value += 1.0 / 60.0;
        }
        if (water2 && water2.material.uniforms && water2.material.uniforms['time']) {
            water2.material.uniforms['time'].value += 1.0 / 60.0;
        }
    }

    function checkCollisions() {
        if (!character || !gameInitialized || isPaused || !animationLoopStarted) return;

        const collisionAudio = document.getElementById('collisionAudio');
        const treasureAudio = document.getElementById('treasureAudio');
        const chancesEl = document.getElementById('chances');
        const treasuresFoundEl = document.getElementById('treasuresFound');
        const collisionsDiv = document.getElementById('collisions');

        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obstacle = obstacles[i];
            if (character.position.distanceTo(obstacle.position) < 0.65) {
                console.log("Collision with obstacle!");
                if(collisionAudio) collisionAudio.play();

                chances--;
                if(chancesEl) chancesEl.innerText = chances;

                if(collisionsDiv){
                    if (chances === 2) collisionsDiv.style.backgroundColor = 'rgba(236,255,0,0.5)';
                    else if (chances === 1) collisionsDiv.style.backgroundColor = 'rgba(255,125,0,0.5)';
                    else if (chances <= 0) collisionsDiv.style.backgroundColor = 'rgba(255,0,0,0.5)';
                    else collisionsDiv.style.backgroundColor = 'rgba(0,255,0,0.5)';
                }

                obstacle.position.z = character.position.z - 150 - Math.random() * 50;
                obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];

                triggerCameraShake(0.5);

                if (chances <= 0) {
                    console.log("Game Over!");
                    const backgroundAudio = document.getElementById('backgroundAudio');
                    if(backgroundAudio) backgroundAudio.pause();
                    alert('Game Over!\nScore: ' + totalPoints + '\nTotal nuggets: ' + treasures + '\nPress OK to restart.');
                    window.location.reload();
                    return;
                }
            }
        }

        for (let i = nuggets.length - 1; i >= 0; i--) {
            const nugget = nuggets[i];
            if (character.position.distanceTo(nugget.position) < 0.7) { 
                console.log("Collected nugget!");
                if(treasureAudio) treasureAudio.play();
                playRandomQuote();

                treasures++;
                chances++;

                if(treasuresFoundEl) treasuresFoundEl.innerText = treasures;
                if(chancesEl) chancesEl.innerText = chances;

                if(collisionsDiv){
                    if (chances === 2) collisionsDiv.style.backgroundColor = 'rgba(236,255,0,0.5)';
                    else if (chances === 1) collisionsDiv.style.backgroundColor = 'rgba(255,125,0,0.5)';
                    else if (chances <= 0) collisionsDiv.style.backgroundColor = 'rgba(255,0,0,0.5)';
                    else collisionsDiv.style.backgroundColor = 'rgba(0,255,0,0.5)';
                }
                nugget.position.z = character.position.z - 150 - Math.random() * 50;
                nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
            }
        }
    }

    function init() {
        console.log("init function started.");
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x95b0c0, 20, 120); 
        if (!raycaster) { // Ensure raycaster is initialized globally
            raycaster = new THREE.Raycaster();
            console.log("Raycaster initialized in init()");
        }

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000000);
        camera.position.set(0, 2.0, 4.0);
        camera.lookAt(0, 0.5, 0);
        console.log("Initial Camera Position:", camera.position);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5;
        document.body.appendChild(renderer.domElement);

        initSky();

        fillLight = new THREE.HemisphereLight(0x8dc1de, 0x00668d, 1.5);
        scene.add(fillLight);
        directionalLight = new THREE.DirectionalLight(0xffffff, 3.0);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);
        scene.add(directionalLight.target);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        renderer.shadowMap.enabled = true;

        console.log("Attempting to add terrain planes.");
        if (heightMapImage.image && HeightMapTexture && heightMapImage.image.complete && heightMapImage.image.naturalHeight !== 0) {
            const size = 256; 
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const context = canvas.getContext('2d');
            context.drawImage(heightMapImage.image, 0, 0, size, size);
            const heightData = context.getImageData(0, 0, size, size).data;
            
            const sideTerrainWidth = 144; 
            const sideTerrainWidthSegments = Math.floor((size - 1) * (sideTerrainWidth / 300)); 
            const sideTerrainDepthSegments = size - 1; 

            const sideTerrainGeometry = new THREE.PlaneGeometry(sideTerrainWidth, forestLength, sideTerrainWidthSegments, sideTerrainDepthSegments);
            
            const s_positions = sideTerrainGeometry.attributes.position;
            const s_widthSegs = sideTerrainGeometry.parameters.widthSegments;
            const s_heightSegs = sideTerrainGeometry.parameters.heightSegments;

            for (let j_s = 0; j_s <= s_heightSegs; j_s++) { 
                for (let i_s = 0; i_s <= s_widthSegs; i_s++) {
                    const index_s = j_s * (s_widthSegs + 1) + i_s;
                    const xPixel = Math.floor((i_s / s_widthSegs) * (size - 1));
                    const yPixel = j_s; 
                    const heightMapPixelIndex = (yPixel * size + xPixel) * 4;
                    
                    if (heightMapPixelIndex < heightData.length) {
                        const height = heightData[heightMapPixelIndex] / 255 * 10;
                        s_positions.setZ(index_s, height);
                    } else {
                         s_positions.setZ(index_s, 0); 
                    }
                }
            }
            sideTerrainGeometry.computeVertexNormals();

            const planeMaterial = new THREE.MeshStandardMaterial({ map: HeightMapTexture });

            leftForestMesh1 = new THREE.Mesh(sideTerrainGeometry, planeMaterial);
            leftForestMesh1.rotation.x = -Math.PI / 2;
            leftForestMesh1.position.y = -2.1; 
            leftForestMesh1.position.x = -6 - (sideTerrainWidth / 2); 
            leftForestMesh1.position.z = -forestLength / 2 + 50;
            leftForestMesh1.receiveShadow = true;
            scene.add(leftForestMesh1);

            rightForestMesh1 = new THREE.Mesh(sideTerrainGeometry.clone(), planeMaterial.clone()); 
            rightForestMesh1.rotation.x = -Math.PI / 2;
            rightForestMesh1.position.y = -2.1;
            rightForestMesh1.position.x = 6 + (sideTerrainWidth / 2);  
            rightForestMesh1.position.z = -forestLength / 2 + 50;
            rightForestMesh1.receiveShadow = true;
            scene.add(rightForestMesh1);

            leftForestMesh2 = new THREE.Mesh(sideTerrainGeometry.clone(), planeMaterial.clone());
            leftForestMesh2.rotation.x = -Math.PI / 2;
            leftForestMesh2.position.y = -2.1;
            leftForestMesh2.position.x = -6 - (sideTerrainWidth / 2);
            leftForestMesh2.position.z = leftForestMesh1.position.z - forestLength;
            leftForestMesh2.receiveShadow = true;
            scene.add(leftForestMesh2);

            rightForestMesh2 = new THREE.Mesh(sideTerrainGeometry.clone(), planeMaterial.clone());
            rightForestMesh2.rotation.x = -Math.PI / 2;
            rightForestMesh2.position.y = -2.1;
            rightForestMesh2.position.x = 6 + (sideTerrainWidth / 2);
            rightForestMesh2.position.z = rightForestMesh1.position.z - forestLength;
            rightForestMesh2.receiveShadow = true;
            scene.add(rightForestMesh2);

            console.log("Dual left/right terrain planes added.");
        } else {
            console.warn("Terrain textures not ready, using placeholder flat terrain.");
            const sideTerrainWidth = 144; 
            const placeholderSideGeo = new THREE.PlaneGeometry(sideTerrainWidth, forestLength);
            const placeholderMat = new THREE.MeshStandardMaterial({ color: 0x335522 });
            
            leftForestMesh1 = new THREE.Mesh(placeholderSideGeo, placeholderMat);
            leftForestMesh1.rotation.x = -Math.PI / 2; 
            leftForestMesh1.position.y = -2.1;
            leftForestMesh1.position.x = -6 - (sideTerrainWidth / 2);
            leftForestMesh1.position.z = -forestLength/2 + 50; scene.add(leftForestMesh1);

            rightForestMesh1 = new THREE.Mesh(placeholderSideGeo.clone(), placeholderMat.clone());
            rightForestMesh1.rotation.x = -Math.PI / 2; 
            rightForestMesh1.position.y = -2.1;
            rightForestMesh1.position.x = 6 + (sideTerrainWidth / 2);
            rightForestMesh1.position.z = -forestLength/2 + 50; scene.add(rightForestMesh1);
            
            leftForestMesh2 = new THREE.Mesh(placeholderSideGeo.clone(), placeholderMat.clone());
            leftForestMesh2.rotation.x = -Math.PI / 2; 
            leftForestMesh2.position.y = -2.1;
            leftForestMesh2.position.x = -6 - (sideTerrainWidth / 2);
            leftForestMesh2.position.z = leftForestMesh1.position.z - forestLength; scene.add(leftForestMesh2);

            rightForestMesh2 = new THREE.Mesh(placeholderSideGeo.clone(), placeholderMat.clone());
            rightForestMesh2.rotation.x = -Math.PI / 2; 
            rightForestMesh2.position.y = -2.1;
            rightForestMesh2.position.x = 6 + (sideTerrainWidth / 2);
            rightForestMesh2.position.z = rightForestMesh1.position.z - forestLength; scene.add(rightForestMesh2);
            
            console.log("Placeholder side terrain planes added.");
        }

        console.log("Attempting to add water planes. Water Normals loaded:", waterNormals && waterNormals.image && waterNormals.image.complete);
        if (Water && waterNormals && waterNormals.image && waterNormals.image.complete && waterNormals.image.naturalHeight !== 0) {
            const waterPlaneGeometry = new THREE.PlaneGeometry(13, waterLength, 10, 50); // Width changed to 13

            let sunDir = new THREE.Vector3(0,1,0);
            if (sky && sky.material.uniforms.sunPosition) {
                sunDir.copy(sky.material.uniforms.sunPosition.value);
                console.log("Water using sunDirection from sky:", sunDir);
            } else if (directionalLight) {
                sunDir.copy(directionalLight.position).normalize();
                console.log("Water using sunDirection from directionalLight:", sunDir);
            } else {
                console.warn("Water: Neither sky nor directionalLight sunPosition available, using default sunDir.");
            }

            const waterOptions = {
                textureWidth: 512, textureHeight: 512, waterNormals: waterNormals,
                sunDirection: sunDir, sunColor: 0xffffff,
                waterColor: 0x00ccff, 
                distortionScale: 2.0,
                fog: true, 
                alpha: 1.0, 
                scale: 4
            };
            water1 = new Water(waterPlaneGeometry, waterOptions);
            water1.rotation.x = -Math.PI / 2;
            water1.position.y = -0.15; 
            water1.position.z = -waterLength / 2 + 50;
            scene.add(water1);

            water2 = new Water(waterPlaneGeometry.clone(), waterOptions); 
            water2.rotation.x = -Math.PI / 2;
            water2.position.y = -0.15; 
            water2.position.z = water1.position.z - waterLength;
            scene.add(water2);
            console.log("Dual water planes added at Y:", water1.position.y);

            const bankMaterial = new THREE.MeshStandardMaterial({ color: 0x6B4423, side: THREE.DoubleSide }); 

            const leftBank1Geometry = new THREE.PlaneGeometry(1, waterLength, 10, 80); 
            const rightBank1Geometry = new THREE.PlaneGeometry(1, waterLength, 10, 80); 
            modifyBankVertices(leftBank1Geometry, true); 
            console.log('Post-modify check for leftBank1Geometry (UUID:', leftBank1Geometry.uuid, '):');
            const firstVertexLX1 = leftBank1Geometry.attributes.position.getX(0);
            const firstVertexLZ1 = leftBank1Geometry.attributes.position.getZ(0);
            console.log('Sample vertex 0 (local X, Z):', firstVertexLX1, firstVertexLZ1);

            modifyBankVertices(rightBank1Geometry, false); 
            console.log('Post-modify check for rightBank1Geometry (UUID:', rightBank1Geometry.uuid, '):');
            const firstVertexRX1 = rightBank1Geometry.attributes.position.getX(0);
            const firstVertexRZ1 = rightBank1Geometry.attributes.position.getZ(0);
            console.log('Sample vertex 0 (local X, Z):', firstVertexRX1, firstVertexRZ1);

            const leftBank1 = new THREE.Mesh(leftBank1Geometry, bankMaterial);
            const rightBank1 = new THREE.Mesh(rightBank1Geometry, bankMaterial);
            leftBank1.rotation.x = -Math.PI / 2;
            leftBank1.position.set(-5.5, water1.position.y - 0.05, water1.position.z); 
            rightBank1.rotation.x = -Math.PI / 2;
            rightBank1.position.set(5.5, water1.position.y - 0.05, water1.position.z);  
            leftBank1.receiveShadow = true; rightBank1.receiveShadow = true;
            scene.add(leftBank1); scene.add(rightBank1);
            leftBankMeshes.push(leftBank1); rightBankMeshes.push(rightBank1);

            const leftBank2Geometry = new THREE.PlaneGeometry(1, waterLength, 10, 80); 
            const rightBank2Geometry = new THREE.PlaneGeometry(1, waterLength, 10, 80); 
            modifyBankVertices(leftBank2Geometry, true);
            console.log('Post-modify check for leftBank2Geometry (UUID:', leftBank2Geometry.uuid, '):');
            const firstVertexLX2 = leftBank2Geometry.attributes.position.getX(0);
            const firstVertexLZ2 = leftBank2Geometry.attributes.position.getZ(0);
            console.log('Sample vertex 0 (local X, Z):', firstVertexLX2, firstVertexLZ2);

            modifyBankVertices(rightBank2Geometry, false);
            console.log('Post-modify check for rightBank2Geometry (UUID:', rightBank2Geometry.uuid, '):');
            const firstVertexRX2 = rightBank2Geometry.attributes.position.getX(0);
            const firstVertexRZ2 = rightBank2Geometry.attributes.position.getZ(0);
            console.log('Sample vertex 0 (local X, Z):', firstVertexRX2, firstVertexRZ2);
            
            const leftBank2 = new THREE.Mesh(leftBank2Geometry, bankMaterial);
            const rightBank2 = new THREE.Mesh(rightBank2Geometry, bankMaterial);
            leftBank2.rotation.x = -Math.PI / 2;
            leftBank2.position.set(-5.5, water2.position.y - 0.05, water2.position.z); 
            rightBank2.rotation.x = -Math.PI / 2;
            rightBank2.position.set(5.5, water2.position.y - 0.05, water2.position.z);  
            leftBank2.receiveShadow = true; rightBank2.receiveShadow = true;
            scene.add(leftBank2); scene.add(rightBank2);
            leftBankMeshes.push(leftBank2); rightBankMeshes.push(rightBank2);
        } else {
            let logMessage = "Water not created. Reasons: ";
            if (!Water) logMessage += "Water class not found. ";
            if (!waterNormals) logMessage += "waterNormals variable not defined. ";
            if (waterNormals && !waterNormals.image) logMessage += "waterNormals.image not defined. ";
            if (waterNormals && waterNormals.image && !waterNormals.image.complete) logMessage += "waterNormals.image not complete. ";
            if (waterNormals && waterNormals.image && waterNormals.image.complete && waterNormals.image.naturalHeight === 0) logMessage += "waterNormals.image has zero height. ";
            console.warn(logMessage);
        }

        const dracoLoader = new DRACOLoader(manager);
        dracoLoader.setDecoderPath( 'three/addons/loaders/draco/' );
        gltfLoader = new GLTFLoader(manager); 
        gltfLoader.setDRACOLoader( dracoLoader );
            
        addCharacter(); 
        initParticleSystem(); 

        gltfLoader.load('3Dmodels/rock.glb', (gltf) => { 
            console.log("Rock model loaded.");
            for (let i = 0; i < 70; i++) {
                const obstacle = gltf.scene.clone();
                const baseScale = 0.08 + Math.random() * 0.42; 
                const yScale = baseScale * (0.7 + Math.random() * 0.6); 
                obstacle.scale.set(baseScale, yScale, baseScale);
                obstacle.rotation.y = Math.random() * Math.PI * 2;
                obstacle.position.set(lanePositions[Math.floor(Math.random() * 3)], -0.20, -20 - i * 20); // Adjusted Y
                obstacle.traverse(node => { if (node.isMesh) node.castShadow = true; });
                obstacles.push(obstacle);
                scene.add(obstacle);
            }
        }, undefined, (error)=>console.error("Error loading rock.glb", error));

        gltfLoader.load('3Dmodels/gold_nugget.glb', (gltf) => {
            console.log("Gold nugget model loaded.");
            for (let i = 0; i < 3; i++) {
                const nugget = gltf.scene.clone();
                const scale = 5.0; 
                nugget.scale.set(scale, scale, scale);
                nugget.position.set(
                    lanePositions[Math.floor(Math.random() * 3)],
                    0.1, 
                    -25 - i * 30 - Math.random() * 10
                );
                console.log("Nugget ["+i+"]: added at X:", nugget.position.x, "Y:", nugget.position.y, "Z:", nugget.position.z);
                nugget.traverse(node => { if (node.isMesh) node.castShadow = true; });
                nuggets.push(nugget);
                scene.add(nugget);
            }
        }, undefined, (error) => console.error("Error loading gold_nugget.glb", error));

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp); 
        document.addEventListener('touchstart', onTouchStart);
        document.addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);
        console.log("init function completed.");
    }

    function addCharacter(){ 
        console.log("addCharacter function called.");
        gltfLoader.load('3Dmodels/Lumberjack_on_a_log.glb', function (gltf) { 
                console.log("Lumberjack_on_a_log.glb loaded successfully in addCharacter.");
                character = gltf.scene;
                character.scale.set(0.4, 0.4, 0.4);
                originalCharacterScaleY = character.scale.y; 
                originalCharacterScaleXZ = character.scale.x;
                const box = new THREE.Box3().setFromObject(character);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                characterBaseYOffset = -(center.y - size.y / 2) - SUBMERGE_AMOUNT;
                character.position.set(lanePositions[currentLane], characterBaseYOffset, -2);
                character.rotation.y = Math.PI;
                character.traverse(node => { if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; }});
                scene.add(character);
                targetLane = currentLane; 
                console.log("Character added to scene. BaseYOffset:", characterBaseYOffset, "Final Y:", character.position.y);

                console.log("Character loaded, now calling addTrees, addGrass, addFishes.");
                if (leftForestMesh1 && rightForestMesh1) { 
                    addTrees();
                    addGrass();
                } else {
                    console.error("Terrain meshes not ready when trying to add trees/grass after character load.");
                }
                addFishes(); 
            },
            xhr => console.log('Lumberjack model ' + (xhr.loaded / xhr.total * 100) + '% loaded'),
            err => console.error('Error loading Lumberjack_on_a_log.glb:', err)
        );
     }
    function updateCamera() {
        if (!character || !camera) return;
        const desiredX = character.position.x;
        const desiredY = character.position.y + 1.0; // Reverted line
        const desiredZ = character.position.z + 1.5;

        camera.position.x = desiredX;
        camera.position.y = desiredY;
        camera.position.z = desiredZ;
    }

    function animate(currentTime) {
        requestAnimationFrame(animate);
        if (!animationLoopStarted || isPaused) {
            if (isPaused && totalPoints < 10 && document.getElementById('countdown') && document.getElementById('countdown').style.display === 'block') {
                 if(renderer && scene && camera) renderer.render(scene, camera);
            }
            return;
        }
        if (firstAnimateCall) { console.log("animate running."); firstAnimateCall = false; }
        if (!character) { if(renderer && scene && camera) renderer.render(scene, camera); return; }

        character.rotation.y += (targetCharacterRotationY - character.rotation.y) * rotationSpeed;
        character.rotation.z += (targetCharacterRotationZ - character.rotation.z) * rotationSpeed;
        if (!isTransitioning && currentLane === targetLane) {
            const defaultRotationY = Math.PI;
            if (Math.abs(character.rotation.y - defaultRotationY) < rotationSpeed * 0.01 ) character.rotation.y = defaultRotationY;
            targetCharacterRotationY = defaultRotationY;
            if (Math.abs(character.rotation.z) < rotationSpeed * 0.01) character.rotation.z = 0;
            targetCharacterRotationZ = 0;
        }
        
        if (character && !isPaused && animationLoopStarted) {
            if (isJumping) {
                jumpProgress += 1 / JUMP_DURATION;
                let currentJumpArcY = 0; 

                // Phase 1: Quick Anticipation (Squash) - unchanged
                if (jumpProgress < 0.15) {
                    character.scale.set(
                        originalCharacterScaleXZ * 1.15,
                        originalCharacterScaleY * 0.7,
                        originalCharacterScaleXZ * 1.15
                    );
                    character.position.y = characterBaseYOffset; 
                } 
                // Phase 2: Upward Stretch with slight lift - unchanged from previous refinement
                else if (jumpProgress < 0.3) { 
                    const stretchProgress = (jumpProgress - 0.15) / (0.3 - 0.15);
                    character.scale.set(
                        originalCharacterScaleXZ * (1.15 - 0.15 * stretchProgress), 
                        originalCharacterScaleY * (0.7 + (1.2 - 0.7) * stretchProgress),
                        originalCharacterScaleXZ * (1.15 - 0.15 * stretchProgress)
                    );
                    character.position.y = characterBaseYOffset + (JUMP_HEIGHT * 0.05 * stretchProgress); 
                } 
                // Phases 3, 4, 5 combined for Y-Position arc calculation:
                // (Covers from jumpProgress 0.3 up to just before 1.0)
                else if (jumpProgress < 1.0) { 
                    // Single arc calculation for the entire main airborne phase
                    const airTimeProgress = (jumpProgress - 0.3) / (1.0 - 0.3); // Maps [0.3, 1.0) of jumpProgress to [0, 1) for sin input
                    currentJumpArcY = (JUMP_HEIGHT * 0.05) + Math.sin(airTimeProgress * Math.PI) * (JUMP_HEIGHT * 0.95);
                    character.position.y = characterBaseYOffset + Math.max(0, currentJumpArcY);

                    // Scaling logic now needs to be nested based on jumpProgress within this block
                    // Phase 3 Scaling: Airtime Normalization (0.3 to 0.7)
                    if (jumpProgress < 0.7) {
                        const airScaleProgress = (jumpProgress - 0.3) / (0.7 - 0.3); 
                        character.scale.set(
                            originalCharacterScaleXZ, 
                            originalCharacterScaleY * (1.2 - (1.2 - 1.0) * airScaleProgress), 
                            originalCharacterScaleXZ
                        );
                    } 
                    // Phase 4 Scaling: Landing Squash (0.7 to 0.85)
                    else if (jumpProgress < 0.85) {
                        const landSquashProgress = (jumpProgress - 0.7) / (0.85 - 0.7); 
                        character.scale.set(
                            originalCharacterScaleXZ * (1.0 + 0.05 * landSquashProgress), 
                            originalCharacterScaleY * (1.0 - (1.0 - 0.9) * landSquashProgress), 
                            originalCharacterScaleXZ * (1.0 + 0.05 * landSquashProgress)
                        );
                    } 
                    // Phase 5 Scaling: Return to Normal (0.85 to 1.0)
                    else { // This covers jumpProgress from 0.85 up to (but not including) 1.0
                        const resetProgress = (jumpProgress - 0.85) / (1.0 - 0.85); 
                        character.scale.set(
                            originalCharacterScaleXZ * (1.05 - 0.05 * resetProgress), 
                            originalCharacterScaleY * (0.9 + (1.0 - 0.9) * resetProgress),   
                            originalCharacterScaleXZ * (1.05 - 0.05 * resetProgress)
                        );
                    }
                }
                // End of jump (jumpProgress >= 1.0)
                else { 
                    console.log("Jump completed. Splash triggered. isJumping:", isJumping, "jumpProgress:", jumpProgress); // Add this log
                    isJumping = false;
                    jumpProgress = 0;
                    character.position.y = characterBaseYOffset; 
                    emitSplash(character.position, 25, 0.18, 0, 1.8, 1.8, 3.0, 1.5); // Front
                    emitSplash(character.position, 25, 0.18, Math.PI / 2, 1.8, 1.8, 3.0, 1.5); // Right side
                    emitSplash(character.position, 25, 0.18, Math.PI, 1.8, 1.8, 3.0, 1.5); // Back
                    emitSplash(character.position, 25, 0.18, 3 * Math.PI / 2, 1.8, 1.8, 3.0, 1.5); // Left side
                    character.scale.set(originalCharacterScaleXZ, originalCharacterScaleY, originalCharacterScaleXZ);
                }
            } else { // Not jumping, apply bobbing
                bobbingAngle += BOBBING_SPEED;
                const bobbingOffset = Math.sin(bobbingAngle) * BOBBING_STRENGTH;
                character.position.y = characterBaseYOffset + bobbingOffset;
            }
        }

        const delta = currentTime - lastTime;
        if (delta >= interval) {
            lastTime = currentTime - (delta % interval);
            animateWater();

            if (leftForestMesh1 && rightForestMesh1 && leftForestMesh2 && rightForestMesh2 && character) {
                leftForestMesh1.position.z += speed;
                rightForestMesh1.position.z += speed;
                leftForestMesh2.position.z += speed;
                rightForestMesh2.position.z += speed;

                if (leftForestMesh1.position.z > character.position.z + forestLength / 2 + 20) {
                    leftForestMesh1.position.z = leftForestMesh2.position.z - forestLength + speed;
                    rightForestMesh1.position.z = rightForestMesh2.position.z - forestLength + speed; 
                }
                if (leftForestMesh2.position.z > character.position.z + forestLength / 2 + 20) {
                    leftForestMesh2.position.z = leftForestMesh1.position.z - forestLength + speed;
                    rightForestMesh2.position.z = rightForestMesh1.position.z - forestLength + speed; 
                }
            }

            if (water1 && water2 && character) {
                water1.position.z += speed;
                water2.position.z += speed;
                if (water1.position.z > character.position.z + waterLength / 2 + 20) {
                    water1.position.z = water2.position.z - waterLength + speed;
                }
                if (water2.position.z > character.position.z + waterLength / 2 + 20) {
                    water2.position.z = water1.position.z - waterLength + speed;
                }
            }

            if (leftBankMeshes.length >= 2 && rightBankMeshes.length >=2 && water1 && water2) {
                leftBankMeshes[0].position.z = water1.position.z;
                rightBankMeshes[0].position.z = water1.position.z;
                leftBankMeshes[1].position.z = water2.position.z;
                rightBankMeshes[1].position.z = water2.position.z;
            }

            for (let obstacle of obstacles) {
                 obstacle.position.z += speed;
                if (character && obstacle.position.z > character.position.z + 20 ) {
                    obstacle.position.z = (character.position.z - 130) - Math.random() * 50;
                    obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];
                } else if (!character && obstacle.position.z > 20) {
                     obstacle.position.z = -130 - Math.random() * 50;
                     obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];
                }
            }
            for (let nugget of nuggets) {
                nugget.position.z += speed;
                if (character && nugget.position.z > character.position.z + 20) {
                    nugget.position.z = (character.position.z - 130) - Math.random() * 100;
                    nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
                } else if (!character && nugget.position.z > 20) {
                    nugget.position.z = -130 - Math.random() * 100;
                    nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
                }
            }

            for (let fish of fishes) {
                const fishJumpHeight = 0.8; 
                const fishJumpDuration = 0.6; 
                const fishJumpFrequency = 0.02; 

                fish.position.z += speed; 

                if (fish.userData === undefined) fish.userData = {};
                fish.userData.previousY = fish.userData.previousY === undefined ? (water1 ? water1.position.y : -0.15) : fish.userData.previousY;
                fish.userData.jumpTime = (fish.userData.jumpTime || 0) + fishJumpFrequency;

                fish.position.y = -0.7 + Math.max(0, Math.sin(fish.userData.jumpTime * Math.PI / fishJumpDuration) * fishJumpHeight);

                const rotationAngle = Math.sin(fish.userData.jumpTime * Math.PI / fishJumpDuration) * Math.PI;
                fish.rotation.x = rotationAngle;
                const waterSurfaceYForFishSplash = water1 ? water1.position.y : -0.15;
                if (fish.userData.previousY <= waterSurfaceYForFishSplash && fish.position.y > waterSurfaceYForFishSplash) { // Exiting water
                    emitSplash(new THREE.Vector3(fish.position.x, waterSurfaceYForFishSplash + 0.05, fish.position.z), 4 + Math.floor(Math.random() * 3), 0.05 + Math.random()*0.03, 0, 1.0, 1.5, 1.2, 1.0);
                }
                else if (fish.userData.previousY > waterSurfaceYForFishSplash && fish.position.y <= waterSurfaceYForFishSplash) { // Entering water
                    emitSplash(new THREE.Vector3(fish.position.x, waterSurfaceYForFishSplash + 0.05, fish.position.z), 4 + Math.floor(Math.random() * 3), 0.05 + Math.random()*0.03, 0, 1.0, 1.5, 1.2, 1.0);
                }
                fish.userData.previousY = fish.position.y;

                if (character && fish.position.z > character.position.z + 20) {
                    const laneIndex = Math.floor(Math.random() * lanePositions.length);
                    fish.position.set(
                        lanePositions[laneIndex] + (Math.random() - 0.5) * 1.5,
                        -0.7, 
                        character.position.z - 130 - Math.random() * 100 
                    );
                    fish.userData.jumpTime = 0;
                    fish.rotation.x = 0; 
                } else if (!character && fish.position.z > 20) { 
                     fish.position.set(
                        lanePositions[Math.floor(Math.random() * 3)] + (Math.random() - 0.5) * 1.5,
                        -0.7,
                        -130 - Math.random() * 100
                    );
                    fish.userData.jumpTime = 0;
                    fish.rotation.x = 0;
                }
            }

            for (let tree of trees) {
                tree.position.z += speed; 
                if (character && tree.position.z > character.position.z + (forestLength / 2) + 20) { // Tree is out of view
                    const side = (Math.random() < 0.5) ? -1 : 1;
                    let newXPos;
                    if (side === -1) { 
                        newXPos = -6 - (Math.random() * (144 - 1));
                    } else { 
                        newXPos = 6 + (Math.random() * (144 - 1));
                    }
                    const newZPos = character.position.z - (forestLength / 2) - Math.random() * (forestLength / 4); 
                    tree.position.x = newXPos;
                    tree.position.z = newZPos;

                    const targetTerrainMesh = getTargetTerrainMesh(newXPos, newZPos);
                    if (targetTerrainMesh && raycaster) {
                        targetTerrainMesh.updateMatrixWorld(); 
                        const origin = new THREE.Vector3(newXPos, 50, newZPos); 
                        const direction = new THREE.Vector3(0, -1, 0); 
                        raycaster.set(origin, direction);
                        const intersects = raycaster.intersectObject(targetTerrainMesh, false);
                        if (intersects.length > 0) {
                            tree.position.y = intersects[0].point.y;
                        } else {
                            tree.position.y = -2.1; 
                            console.warn(`Tree raycast (recycle) FAILED. Tree XZ: (${newXPos.toFixed(2)}, ${newZPos.toFixed(2)}). Target: ${targetTerrainMesh.uuid}, Target_Z: ${targetTerrainMesh.position.z.toFixed(2)}`);
                        }
                    } else {
                        tree.position.y = -2.1; 
                        let reason = !targetTerrainMesh ? "No target terrain mesh" : "No raycaster";
                        console.warn(`No target or raycaster for recycled tree (${reason}). Tree XZ: (${newXPos.toFixed(2)}, ${newZPos.toFixed(2)})`);
                    }

                    const randomScaleBase = 1.5 + Math.random() * 1.0;
                    const randomScaleY = randomScaleBase * (1.0 + Math.random() * 1.0);
                    tree.scale.set(randomScaleBase, randomScaleY, randomScaleBase);
                    tree.rotation.y = Math.random() * Math.PI * 2;

                } else if (!character && tree.position.z > (forestLength / 2) + 20) { 
                    const side = (Math.random() < 0.5) ? -1 : 1;
                     if (side === -1) { 
                        tree.position.x = -6 - (Math.random() * (144 - 1));
                    } else { 
                        tree.position.x = 6 + (Math.random() * (144 - 1));
                    }
                    tree.position.z = -(forestLength / 2) - Math.random() * (forestLength/2);
                }
            }

            if (leavesMaterial && leavesMaterial.uniforms && leavesMaterial.uniforms.time) {
                leavesMaterial.uniforms.time.value = clock.getElapsedTime();
            }

            for (let grassPatch of grasss) { 
                grassPatch.position.z += speed;

                if (character && grassPatch.position.z > character.position.z + (forestLength / 2) + 20) {
                    const side = (Math.random() < 0.5) ? -1 : 1;
                    let newXPos;
                    if (side === -1) { 
                        newXPos = -6 - (2.5 + Math.random() * (144 - 5));
                    } else { 
                        newXPos = 6 + (2.5 + Math.random() * (144 - 5));
                    }
                    const newZPos = character.position.z - (forestLength / 2) - Math.random() * (forestLength / 2);
                    grassPatch.position.x = newXPos;
                    grassPatch.position.z = newZPos;

                    const targetTerrainMesh = getTargetTerrainMesh(newXPos, newZPos);
                    if (targetTerrainMesh && raycaster) {
                        targetTerrainMesh.updateMatrixWorld(); 
                        const rayOrigin = new THREE.Vector3(newXPos, 50, newZPos);
                        const rayDirection = new THREE.Vector3(0, -1, 0);
                        raycaster.set(rayOrigin, rayDirection);
                        const intersects = raycaster.intersectObject(targetTerrainMesh, false);
                        if (intersects.length > 0) {
                            grassPatch.position.y = intersects[0].point.y;
                        } else {
                            grassPatch.position.y = -2.1; 
                            console.warn(`Grass patch raycast (recycle) FAILED. Patch XZ: (${newXPos.toFixed(2)}, ${newZPos.toFixed(2)}). Target: ${targetTerrainMesh.uuid}, Target_Z: ${targetTerrainMesh.position.z.toFixed(2)}`);
                        }
                    } else {
                        grassPatch.position.y = -2.1; 
                        let reason = !targetTerrainMesh ? "No target terrain mesh" : "No raycaster";
                        console.warn(`No target or raycaster for recycled grass patch (${reason}). Patch XZ: (${newXPos.toFixed(2)}, ${newZPos.toFixed(2)})`);
                    }

                } else if (!character && grassPatch.position.z > (forestLength / 2) + 20) { 
                    const side = (Math.random() < 0.5) ? -1 : 1;
                    if (side === -1) { 
                        grassPatch.position.x = -6 - (2.5 + Math.random() * (144 - 5));
                    } else { 
                        grassPatch.position.x = 6 + (2.5 + Math.random() * (144 - 5));
                    }
                    grassPatch.position.z = -(forestLength / 2) - Math.random() * (forestLength / 2);
                }
            }

            updateParticles(1/fps); 

            // Bank Edge Splashes / Foam
            if (character && water1 && !isPaused && animationLoopStarted && bankSplashGlobalCooldown) {
                const now = performance.now();
                const bankSplashCooldownPeriod = 75; // milliseconds
                if (now - bankSplashGlobalCooldown.lastBankSplashTime > bankSplashCooldownPeriod) {
                    // console.log(`Emitting bank splashes at time: ${now}`); 
                    bankSplashGlobalCooldown.lastBankSplashTime = now;

                    const characterZ = character.position.z;
                    const viewMinZ = characterZ - BANK_SPLASH_VIEW_LENGTH / 2;
                    const viewMaxZ = characterZ + BANK_SPLASH_VIEW_LENGTH / 2;
                    const waterY = water1.position.y + 0.05; // Slightly above water surface

                    for (let z = viewMinZ; z < viewMaxZ; z += (1 / BANK_SPLASH_DENSITY)) {
                        if (Math.random() < 0.7) continue; // Random chance to skip some, for sparser effect

                        const randomXOffset = (Math.random() - 0.5) * 0.5; // Small random sideways jitter
                        
                        // Left Bank
                        const leftBankEmitterX = -6.0 + randomXOffset; 
                        const emitPosLeft = new THREE.Vector3(leftBankEmitterX, waterY, z);
                        emitSplash(emitPosLeft,
                           1,                                  // count: 1 particle per emission event
                           0.01 + Math.random() * 0.01,        // baseVelocity: very low
                           (Math.PI * 0.15 + (Math.random() - 0.5) * 0.4), // currentAngleOffset for left
                           1.0,                                // speedMultiplier
                           0.1 + Math.random() * 0.1,          // upwardSpeedBias: very low, for a flat effect
                           0.4 + Math.random() * 0.3,          // particleScaleMultiplier: small particles
                           2.5 + Math.random() * 1.0           // lifeMultiplier: relatively long for a lingering, foamy look
                          ); 

                        // Right Bank
                        const rightBankEmitterX = 6.0 + randomXOffset;
                        const emitPosRight = new THREE.Vector3(rightBankEmitterX, waterY, z);
                        emitSplash(emitPosRight,
                           1,                                  // count: 1 particle per emission event
                           0.01 + Math.random() * 0.01,        // baseVelocity: very low
                           (Math.PI * 0.85 + (Math.random() - 0.5) * 0.4), // currentAngleOffset for right
                           1.0,                                // speedMultiplier
                           0.1 + Math.random() * 0.1,          // upwardSpeedBias: very low, for a flat effect
                           0.4 + Math.random() * 0.3,          // particleScaleMultiplier: small particles
                           2.5 + Math.random() * 1.0           // lifeMultiplier: relatively long for a lingering, foamy look
                          );
                    }
                }
            }

            const waterSurfaceY = water1 ? water1.position.y : -0.15;
            for (let obstacle of obstacles) {
                const rockBaseApproxY = obstacle.position.y - (obstacle.scale.y * 0.5);
                const isLargeRock = obstacle.scale.x > 0.3;

                if (Math.abs(rockBaseApproxY - waterSurfaceY) < 0.3 && obstacle.position.z < (character ? character.position.z : 0) + 10 && obstacle.position.z > (character ? character.position.z : 0) - 70) {
                    obstacle.userData = obstacle.userData || {};
                    const now = performance.now();

                    // Common front splash for all rocks
                    const frontSplashCooldown = 120 + Math.random() * 100;
                    if (!obstacle.userData.lastFrontSplashTime || (now - obstacle.userData.lastFrontSplashTime > frontSplashCooldown)) {
                        const frontSplashPos = new THREE.Vector3(obstacle.position.x, waterSurfaceY + 0.05, obstacle.position.z - obstacle.scale.z * 0.5);
                        // Adjusted for small rocks, large rocks will use this too for now.
                        emitSplash(frontSplashPos, 3 + Math.floor(Math.random() * 3), 0.06 + Math.random() * 0.02, -Math.PI / 2 + (Math.random() - 0.5) * 0.4, 1.0, 0.8, 1.5, 1.5);
                        obstacle.userData.lastFrontSplashTime = now;
                    }

                    if (!isLargeRock) {
                        // Existing splash logic for smaller rocks
                        const rearWakeCooldown = 100 + Math.random() * 100;
                        if (!obstacle.userData.lastRearWakeTime || (now - obstacle.userData.lastRearWakeTime > rearWakeCooldown)) {
                            const rearEmitterOffset = obstacle.scale.z * 0.3;
                            const vSpreadAngle = Math.PI / 6;

                            const wakePos1 = new THREE.Vector3(obstacle.position.x - obstacle.scale.x * 0.2, waterSurfaceY + 0.05, obstacle.position.z + rearEmitterOffset);
                            emitSplash(wakePos1, 3 + Math.floor(Math.random() * 3), 0.04 + Math.random() * 0.02, Math.PI / 2 + vSpreadAngle, 1.0, 0.5, 1.5, 1.8);

                            const wakePos2 = new THREE.Vector3(obstacle.position.x + obstacle.scale.x * 0.2, waterSurfaceY + 0.05, obstacle.position.z + rearEmitterOffset);
                            emitSplash(wakePos2, 3 + Math.floor(Math.random() * 3), 0.04 + Math.random() * 0.02, Math.PI / 2 - vSpreadAngle, 1.0, 0.5, 1.5, 1.8);
                            
                            obstacle.userData.lastRearWakeTime = now;
                        }

                        const sideSplashCooldown = 150 + Math.random() * 100;
                        if (!obstacle.userData.lastSideSplashTime || (now - obstacle.userData.lastSideSplashTime > sideSplashCooldown)) {
                            const sideSplashPosLeft = new THREE.Vector3(obstacle.position.x - obstacle.scale.x * 0.55, waterSurfaceY + 0.05, obstacle.position.z);
                            emitSplash(sideSplashPosLeft,
                                       2 + Math.floor(Math.random() * 3), 0.025 + Math.random() * 0.015, (Math.PI * 3/4) + (Math.random() - 0.5) * 0.4,
                                       1.0, 0.4, 1.3, 1.5 ); // count and particleScaleMultiplier adjusted
                
                            const sideSplashPosRight = new THREE.Vector3(obstacle.position.x + obstacle.scale.x * 0.55, waterSurfaceY + 0.05, obstacle.position.z);
                            emitSplash(sideSplashPosRight,
                                       2 + Math.floor(Math.random() * 3), 0.025 + Math.random() * 0.015, (Math.PI * 1/4) + (Math.random() - 0.5) * 0.4,
                                       1.0, 0.4, 1.3, 1.5 ); // count and particleScaleMultiplier adjusted
                            obstacle.userData.lastSideSplashTime = now;
                        }
                    } else { // isLargeRock is true
                        const largeRockWakeCooldown = 100 + Math.random() * 80;
                        if (!obstacle.userData.lastLargeRockWakeTime || (now - obstacle.userData.lastLargeRockWakeTime > largeRockWakeCooldown)) {
                            const rockRadiusX = obstacle.scale.x * 0.5;
                            const rockRadiusZ = obstacle.scale.z * 0.5; // Assuming scale.z is representative for front/back offset

                            // Right side
                            emitSplash(new THREE.Vector3(obstacle.position.x + rockRadiusX, waterSurfaceY + 0.05, obstacle.position.z), 4, 0.02, 0, 1.0, 0.2, 1.0, 2.0); // count increased
                            // Left side
                            emitSplash(new THREE.Vector3(obstacle.position.x - rockRadiusX, waterSurfaceY + 0.05, obstacle.position.z), 4, 0.02, Math.PI, 1.0, 0.2, 1.0, 2.0); // count increased
                            // Back (relative to rock center, assuming +Z is "back" of rock if it were moving)
                            emitSplash(new THREE.Vector3(obstacle.position.x, waterSurfaceY + 0.05, obstacle.position.z + rockRadiusZ), 4, 0.02, Math.PI / 2, 1.0, 0.2, 1.0, 2.0); // count increased
                            // Front (relative to rock center, distinct from the existing directional front splash)
                            emitSplash(new THREE.Vector3(obstacle.position.x, waterSurfaceY + 0.05, obstacle.position.z - rockRadiusZ), 4, 0.02, -Math.PI / 2, 1.0, 0.2, 1.0, 2.0); // count increased
                            
                            obstacle.userData.lastLargeRockWakeTime = now;
                        }
                    }
                }
            }

            if (character && speed > 0.05 && animationLoopStarted && !isPaused) { 
                character.userData = character.userData || {};
                const now = performance.now();
                const rearWakeCooldown = 50 + Math.random() * 50; 

                if (!character.userData.lastRearWakeTime || (now - character.userData.lastRearWakeTime > rearWakeCooldown)) {
                    const waterYWake = water1 ? water1.position.y : -0.15;
                    const rearWakePosition = new THREE.Vector3(
                        character.position.x, 
                        waterYWake + 0.05, 
                        character.position.z + 0.7 
                    );
                    emitSplash(rearWakePosition, 2 + Math.floor(Math.random() * 3), 0.03 + Math.random()*0.03, Math.PI / 2, 1.0, 0.6, 1.0, 1.0); 
                    character.userData.lastRearWakeTime = now;
                }
            }

            updatePoints();
            updateCamera();
            if (character && camera && directionalLight) {
                directionalLight.position.set(camera.position.x + 1.5, camera.position.y + 3, camera.position.z + 0.5); 
                directionalLight.target.position.copy(character.position);
                directionalLight.target.updateMatrixWorld(); 
            }
            checkCollisions();
            applyCameraShake();
            if(renderer && scene && camera) renderer.render(scene, camera);
            else console.error("Render call skipped: renderer, scene or camera missing.");

            const Announcement = document.getElementById('Announcement');
            const dashboard = document.getElementById('dashboard');
            const pauseButton = document.getElementById('pauseButton');
            const countdown = document.getElementById('countdown');

            if(totalPoints === 10 && Announcement && Announcement.style.display !== 'none' && !window.countdownStarted){
                window.countdownStarted = true;
                Announcement.style.display = 'none';
                if (!isPaused) togglePause();
                else {
                    if(dashboard) dashboard.style.display = 'block';
                    if(pauseButton) pauseButton.style.display = 'block';
                }
                if(countdown) countdown.style.display = 'block';
                let countdownValue = 3;
                if(countdown) countdown.innerText = countdownValue;

                if (currentCountdownInterval) clearInterval(currentCountdownInterval);
                currentCountdownInterval = setInterval(() => {
                    countdownValue -= 1;
                    if(countdown) {
                        if (countdownValue > 0) {
                            countdown.innerText = countdownValue;
                        } else {
                            clearInterval(currentCountdownInterval);
                            currentCountdownInterval = null;
                            countdown.style.display = 'none';
                            if(isPaused) togglePause();
                            const backgroundAudio = document.getElementById('backgroundAudio');
                            if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed post-countdown:", e));
                        }
                    } else { clearInterval(currentCountdownInterval); currentCountdownInterval = null;}
                }, 1000);
            }
        }
    }

    function initiateAnimationLoop() {
        console.log("initiateAnimationLoop called.");
        console.log(`Flags before starting: gameReadyToStartByUser: ${gameReadyToStartByUser}, assetsLoaded: ${assetsLoaded}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);

        if (!assetsLoaded || !gameInitialized) {
            console.error("Attempted to initiate animation loop, but assets or game not initialized!");
            return;
        }
        if (animationLoopStarted) {
            console.warn("Animation loop already initiated. Ignoring call.");
            if (isPaused) togglePause();
            return;
        }

        const backgroundAudio = document.getElementById('backgroundAudio');
        if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed in initiateAnimationLoop:", e));

        let needsInitialPauseForCountdown = (totalPoints < 10);

        if (needsInitialPauseForCountdown && !isPaused) {
            console.log("initiateAnimationLoop: Initializing first pause for countdown.");
            togglePause();
        } else if (isPaused && !needsInitialPauseForCountdown) {
            console.log("initiateAnimationLoop: Game was paused by user, toggling to resume.");
            togglePause();
        } else if (isPaused && needsInitialPauseForCountdown) {
            console.log("initiateAnimationLoop: Already paused, likely for countdown.");
        }

        firstAnimateCall = true;
        animationLoopStarted = true;

        animate();
        console.log("Animation loop requested. animationLoopStarted set to true.");
    }

    window.startGame = function() {
        console.log("startGame function called by button click.");
        const announcementDiv = document.getElementById('Announcement');
        if(announcementDiv) announcementDiv.style.display = 'none';

        const dashboard = document.getElementById('dashboard');
        const pauseButton = document.getElementById('pauseButton');
        if(dashboard) dashboard.style.display = 'block';
        if(pauseButton) pauseButton.style.display = 'block';

        gameReadyToStartByUser = true;
        console.log(`startGame: Flags - gameReadyToStartByUser: ${gameReadyToStartByUser}, assetsLoaded: ${assetsLoaded}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);

        if (assetsLoaded && gameInitialized && !animationLoopStarted) {
            console.log("startGame: Conditions met to start animation.");
            initiateAnimationLoop();
        } else if (assetsLoaded && gameInitialized && animationLoopStarted) {
            console.log("startGame: Animation loop already started.");
            if(isPaused) {
                console.log("startGame: Was paused, toggling pause to resume.");
                togglePause();
            }
        } else {
            console.log("startGame: Conditions NOT met to start animation immediately.");
            if (!assetsLoaded) console.log("Reason: Assets not yet loaded.");
            if (!gameInitialized) console.log("Reason: Game not yet initialized.");
        }
    }

    function togglePause() {
        isPaused = !isPaused;
        const backgroundAudio = document.getElementById('backgroundAudio');
        const pauseButton = document.getElementById('pauseButton');
        const countdown = document.getElementById('countdown');
        const announcementDiv = document.getElementById('Announcement');

        if (!isPaused) {
            lastTime = performance.now();
            if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed on resume:", e));
            if(pauseButton) pauseButton.innerText = "Pause";
            if(countdown) countdown.style.display = "none";
            if (gameInitialized && assetsLoaded && gameReadyToStartByUser && !animationLoopStarted) {
                console.log("togglePause (resuming): Conditions met, ensuring animation loop starts.");
                initiateAnimationLoop();
            } else if (!animationLoopStarted) {
                 console.log("togglePause (resuming): Animation loop not started, but conditions might not be fully met yet or it's handled by initiateAnimationLoop.");
            }
        } else {
            if(backgroundAudio) backgroundAudio.pause();
            if(pauseButton) pauseButton.innerText = "Resume";
            if(countdown && announcementDiv && (totalPoints >= 10 || (totalPoints < 10 && announcementDiv.style.display === 'none') ) ){
                 countdown.style.display = "block";
                 countdown.style.cursor = "pointer";
                 countdown.innerText = "Game Paused";
                 countdown.onclick = togglePause;
            } else if (countdown && totalPoints === 0 && !gameReadyToStartByUser){
                 // This is initial auto-pause for countdown, text set by interval in animate
            }
        }
        console.log("Game paused state:", isPaused);
     }

    document.getElementById('pauseButton').addEventListener('click', togglePause);
    console.log("End of script module parsing. Event listeners attached. Waiting for asset loading or user interaction.");

</script>


<div id="dashboard">
    <div id="totalpointscontained"><span id="totalPoints">0</span></div>
    <div id="collisions" style="vertical-align: middle;"><span id="chances">3</span></div>
    <div id="nuggetscontained">
        <img src="media/goldnugget.png" style="width:3vw; vertical-align: middle;">
        <span id="treasuresFound" style="color:black; vertical-align: middle;">0</span>
    </div>
</div>

<div id="pauseButton">Pause</div>
<div id="countdown"></div>

<div id="Announcement">
    <img src="media/ridingonittitle.jpeg" style="max-height:50%;">
    <h1>I'm Riding on it!</h1>
    <div onclick="startGame()" style="padding:20px; background-color:gray; border-radius:5px;">
        <span id="Menu" style="font-size:3vw; color:black; cursor:pointer;">Click here to Start the game</span>
    </div>
    <div style="margin-top:10px; font-size:1.5vw;">Let's ride on the river while avoiding the rocks, and collecting the gold nuggets!</div>
    <div><a href="light.html">Click here if you need lower graphic for better game rending.</a></div>
</div>
</body>
</html>
