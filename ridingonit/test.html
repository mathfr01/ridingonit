<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="I'm riding on it!">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    <title>I'm riding on it!</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info { position: absolute; top: 10px; text-align: center; z-index: 100; color: white; background-color:black; padding:5px; border-radius:5px; }
        #dashboard {
            display: none; 
            position:absolute; 
            top:1px; left:50%; 
            transform: translateX(-50%); 
            text-align:center; 
            z-index:10; 
            min-width:350px; 
            max-height:10%; 
            color:white; 
            padding:3px; 
            border-radius:15px;
            font-size:4vw;
            }
        #chances {margin:5px;}
        #collisions {margin:5px;  min-width:4vw; min-height:3vw; border-radius:3vw; background-color: rgba(0,255,0,0.5); padding:7px; display: inline-block; color:black;}
        #totalpointscontained { margin:5px; min-height:2vw; vertical-align: middle; padding:7px; border-radius:3px; background-color: rgba(255,255,255,0.5); display: inline-block; color:black;}
        #nuggetscontained { margin:5px; min-height:2vw; vertical-align: middle; padding:7px; border-radius:3px; background-color: rgba(255,255,255,0.5); display: inline-block; color:black;}
        #totalPoints {color:black;}
        #Announcement {display: block; position:absolute; width:50%; height:50%; margin-left:25%; bottom:25%; background-color:white; color:darkgray; text-align:center;}
        button{font-size:large;}
        #pauseButton { display: none; position:absolute; top:1px; right:1px; color:white; font-size:3vw; cursor: pointer; }
        #countdown { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 5vw; color: white; background-color: black; padding: 20px; border-radius: 10px; }
   </style>
</head>
<body>

<!-- Add the audio element here -->
<audio id="backgroundAudio" src="sounds/RiverStream.mp3" loop></audio>
<audio id="collisionAudio" src="sounds/collision.mp3"></audio>
<audio id="treasureAudio" src="sounds/treasureFound.mp3"></audio>
<audio id="turnAudio" src="sounds/turn.mp3"></audio>
<audio id="Quote1" src="sounds/61-0429E-The-Uncertain-Sound-_69m-54s-70m-12s_-VGR.mp3"></audio>
<audio id="Quote2" src="sounds/61-0429E-The-Uncertain-Sound-_91m-7s-91m-20s_-VGR.mp3"></audio>
<audio id="Quote3" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_86m-37s-87m-3s_-VGR.mp3"></audio>
<audio id="Quote4" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_91m-8s-91m-26s_-VGR.mp3"></audio>
<audio id="Quote5" src="sounds/63-0114-A-Trumpet-Gives-An-Uncertain-Sound-_92m-5s-92m-45s_-VGR.mp3"></audio>
<audio id="Quote6" src="sounds/63-0608-Conferences-_98m-14s-98m-39s_-VGR.mp3"></audio>
<audio id="Quote7" src="sounds/63-0608-Conferences-_98m-57s-99m-21s_-VGR.mp3"></audio>
<audio id="Quote8" src="sounds/64-0206E-Gods-Provided-Way-For-This-Day-_39m-28s-39m-46s_-VGR.mp3"></audio>

<script>
    let simpleNoise = `
  float N (vec2 st) { // https://thebookofshaders.com/10/
      return fract( sin( dot( st.xy, vec2(12.9898,78.233 ) ) ) *  43758.5453123);
  }
  
  float smoothNoise( vec2 ip ){ 
      vec2 lv = fract( ip );
    vec2 id = floor( ip );
    
    lv = lv * lv * ( 3. - 2. * lv );
    
    float bl = N( id );
    float br = N( id + vec2( 1, 0 ));
    float b = mix( bl, br, lv.x );
    
    float tl = N( id + vec2( 0, 1 ));
    float tr = N( id + vec2( 1, 1 ));
    float t = mix( tl, tr, lv.x );
    
    return mix( b, t, lv.y );
  }
`;
</script>

<script type="importmap">
  {
    "imports": {
        "three": "./three.module.js",
        "three/addons/": "./addons/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { Sky } from 'three/addons/objects/Sky.js';
import { Water } from 'three/addons/objects/Water.js';

    console.log("Script module parsing started. Version 13 (Full Integration Test).");

    let scene, camera, renderer, character, sky, sun, water1, water2, fillLight, directionalLight, gltfLoader; // Consolidated and added gltfLoader
    let obstacles = [];
    let nuggets = [];
    let trees = [];
    let fishes = []; // This remains
    let grasss = [];
    let leftBankMeshes = [];
    let rightBankMeshes = [];
    let forestMesh1, forestMesh2; // For dual plane terrain looping
    const forestLength = 600; // Length of one terrain/water segment
    const waterLength = 600;  // Length of one water segment

    let lanePositions = [-2, 0, 2];
    let currentLane = 1;
    let speed = 0.1;
    let chances = 3;
    const SUBMERGE_AMOUNT = 0.3; // Adjusted for more submersion
    let CharacterInitialY = 0;
    let characterBaseYOffset = 0;

    let targetCharacterRotationY = Math.PI;
    let targetCharacterRotationZ = 0;
    const LEAN_ANGLE = Math.PI / 15;
    let rotationSpeed = 0.1;

    let treasures = 0;
    const clock = new THREE.Clock();
    let QuoteNumber;
    let RandomQuote = null;
    let totalPoints = 0;
    let isTransitioning = false;
    let targetLane = 1;
    let isPaused = false;

    let shakeDuration = 0;
    let shakeTime = 0;

    let lastTime = 0;
    const fps = 30;
    const interval = 1000 / fps;

    let gameReadyToStartByUser = false;
    let assetsLoaded = false;
    let gameInitialized = false;
    let animationLoopStarted = false;
    let firstAnimateCall = true;
    let waterNormals;
    let currentCountdownInterval = null;
    window.countdownStarted = false;

    const manager = new THREE.LoadingManager();
    manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
        console.log( `LoadingManager: Loading file: ${url}. Loaded ${itemsLoaded} of ${itemsTotal} files.` );
    };
    manager.onLoad = () => {
      console.log('LoadingManager: All assets loaded callback triggered.');
      assetsLoaded = true;

      if (!gameInitialized) {
          console.log('LoadingManager.onLoad: Game not initialized yet. Calling init().');
          init();
          gameInitialized = true;
      } else {
          console.log('LoadingManager.onLoad: Game already initialized. Skipping init().');
      }

      console.log(`LoadingManager.onLoad: Flags - gameReadyToStartByUser: ${gameReadyToStartByUser}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);
      if (gameReadyToStartByUser && gameInitialized && !animationLoopStarted) {
          console.log("LoadingManager.onLoad: Conditions met to start animation.");
          initiateAnimationLoop();
      } else {
          console.log("LoadingManager.onLoad: Conditions NOT met to start animation yet.");
          if (!gameReadyToStartByUser) console.log("Reason: User hasn't clicked start.");
          if (!gameInitialized) console.log("Reason: Game not initialized (should not happen if this far).");
          if (animationLoopStarted) console.log("Reason: Animation loop already started.");
      }
    };
    manager.onError = (url) => {
      console.error('LoadingManager: There was an error loading ' + url);
    };

    const textureLoader = new THREE.TextureLoader(manager);
    const heightMapImage = textureLoader.load('media/HeightMap.jpg',
        () => console.log("Texture media/HeightMap.jpg loaded successfully."),
        undefined,
        (err) => console.error("Error loading media/HeightMap.jpg via TextureLoader:", err)
    );
    const HeightMapTexture = textureLoader.load('media/HeightMapTexture.jpg',
        () => console.log("Texture media/HeightMapTexture.jpg loaded successfully."),
        undefined,
        (err) => console.error("Error loading media/HeightMapTexture.jpg via TextureLoader:", err)
    );
    waterNormals = textureLoader.load('media/waternormals.jpg', function ( texture ) {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        console.log("Texture media/waternormals.jpg for water loaded successfully.");
    }, undefined, (err) => console.error("Error loading media/waternormals.jpg for water:", err));

    const grassVertexShader = `
      varying vec2 vUv;
      uniform float time;
      
      ${simpleNoise} // Ensure simpleNoise is defined in this scope
      
        void main() {
            vUv = uv;
            float t = time * 2.;
            
            vec4 mvPosition = vec4( position, 1.0 );
            #ifdef USE_INSTANCING
                mvPosition = instanceMatrix * mvPosition;
            #endif
            
            float noise = smoothNoise(mvPosition.xz * 0.5 + vec2(0., t));
            noise = pow(noise * 0.5 + 0.5, 2.) * 2.;
            
            float dispPower = 1. - cos( uv.y * 3.1416 * 0.5 );
            float displacement = noise * ( 0.3 * dispPower );
            mvPosition.z -= displacement; 
            
            vec4 modelViewPosition = modelViewMatrix * mvPosition;
            gl_Position = projectionMatrix * modelViewPosition;
        }
    `;

    const grassFragmentShader = `
      varying vec2 vUv;
      
      void main() {
        vec3 baseColor = vec3( 0.41, 1.0, 0.5 ); 
        float clarity = ( vUv.y * 0.875 ) + 0.125;
        gl_FragColor = vec4( baseColor * clarity, 1 );
      }
    `;

    const grassUniforms = {
        time: { value: 0 }
    };

    const leavesMaterial = new THREE.ShaderMaterial({
        vertexShader: grassVertexShader,
        fragmentShader: grassFragmentShader,
        uniforms: grassUniforms,
        side: THREE.DoubleSide
    });

    function createSplashTexture() {
       const canvas = document.createElement('canvas');
       canvas.width = 64;
       canvas.height = 64;
       const context = canvas.getContext('2d');
       
       const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
       gradient.addColorStop(0, 'rgba(255,255,255,0.8)');
       gradient.addColorStop(0.5, 'rgba(200,200,255,0.5)');
       gradient.addColorStop(1, 'rgba(150,150,255,0)');
       
       context.fillStyle = gradient;
       context.fillRect(0, 0, 64, 64);
       
       return new THREE.CanvasTexture(canvas);
    }
    const splashTexture = createSplashTexture();

    let particlePool = [];
    const maxParticles = 100; 
    let particleSystemContainer; 

      function modifyBankVertices(geometry, isLeftBank) {
          console.log('Modifying bank vertices for:', isLeftBank ? 'Left Bank' : 'Right Bank', 'ID:', geometry.uuid); // Added
          const positions = geometry.attributes.position;
          // const widthSegments = geometry.parameters.widthSegments; // Original, to be commented
          // const depthSegments = geometry.parameters.depthSegments; // Original, to be commented
          // const halfWidth = geometry.parameters.width / 2; // Original, to be commented

          /* // Original loops to be commented out
          for (let j = 0; j <= depthSegments; j++) { 
              for (let i = 0; i <= widthSegments; i++) { 
                  const index = j * (widthSegments + 1) + i;
                  
                  let isOuterEdgeVertex = false;
                  if (isLeftBank && i === 0) { 
                      isOuterEdgeVertex = true;
                  } else if (!isLeftBank && i === widthSegments) { 
                      isOuterEdgeVertex = true;
                  }

                  if (isOuterEdgeVertex) {
                      let currentLocalY = positions.getY(index);
                      currentLocalY += (Math.random() - 0.5) * 5.0; 
                      positions.setY(index, currentLocalY);

                      let currentLocalX = positions.getX(index);
                      currentLocalX += (Math.random() - 0.5) * 2.0; 
                      positions.setX(index, currentLocalX);
                  }
              }
          }
          */ // End of original loops comment

          // New Universal Test Logic:
          if (positions.count > 0) {
              let originalY = positions.getY(0);
              positions.setY(0, 20.0); // Set local Y of vertex 0 to an absolute high value
              console.log(`Bank ${geometry.uuid}: Set vertex 0 original Y: ${originalY}, new Y: ${positions.getY(0)}`);
          } else {
              console.log(`Bank ${geometry.uuid}: No vertices found (count is 0).`);
          }
          
          positions.needsUpdate = true;
          geometry.computeVertexNormals();
      }

    function initSky() {
        console.log("initSky function called.");
        sky = new Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);
        sun = new THREE.Vector3();
        const effectController = {
            turbidity: 10, rayleigh: 2, mieCoefficient: 0.005, mieDirectionalG: 0.7,
            elevation: 10, azimuth: 180, exposure: 0.5
        };
        const uniforms = sky.material.uniforms;
        uniforms['turbidity'].value = effectController.turbidity;
        uniforms['rayleigh'].value = effectController.rayleigh;
        uniforms['mieCoefficient'].value = effectController.mieCoefficient;
        uniforms['mieDirectionalG'].value = effectController.mieDirectionalG;
        const phi = THREE.MathUtils.degToRad(90 - effectController.elevation);
        const theta = THREE.MathUtils.degToRad(effectController.azimuth);
        sun.setFromSphericalCoords(1, phi, theta);
        uniforms['sunPosition'].value.copy(sun);
        if(renderer) renderer.toneMappingExposure = effectController.exposure;
        console.log("Sky initialized and added to scene.");
    }
    function addTrees() {
        console.log("addTrees function called.");
        if (!gltfLoader) {
            console.error("gltfLoader not initialized in addTrees.");
            return;
        }
        if (!character || !forestMesh1 || !forestMesh2) {
            console.warn("Character or terrain not ready in addTrees, will retry or skip if necessary.");
            // Attempt to add trees only if character and terrain are loaded
            // This check might need to be more robust, e.g., by deferring or using a flag
            if (!character) {
                console.log("addTrees: Character not ready.");
                return;
            }
            if(!forestMesh1 || !forestMesh2){
                console.log("addTrees: Forest meshes not ready.");
                return;
            }
        }

        gltfLoader.load(
            '3Dmodels/pine_tree.glb',
            function(gltf) {
                console.log("Pine tree model loaded.");
                const treeModel = gltf.scene;
                const numTrees = 100; // Number of trees for recycling pool

                for (let i = 0; i < numTrees; i++) {
                    const tree = treeModel.clone();
                    const side = (i % 2 === 0) ? -1 : 1; // -1 for left, 1 for right
                    const xPos = side * (5 + 1 + Math.random() * 15); 
                    const zPos = (character.position.z - forestLength / 2) + (Math.random() * forestLength);

                    tree.position.set(
                        xPos,
                        forestMesh1.position.y + 0.01, 
                        zPos
                    );

                    const randomScaleBase = 1.5 + Math.random() * 1.0; 
                    const randomScaleY = randomScaleBase * (1.0 + Math.random() * 1.0); 
                    tree.scale.set(randomScaleBase, randomScaleY, randomScaleBase);
                    tree.rotation.y = Math.random() * Math.PI * 2;

                    tree.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true; 
                        }
                    });
                    trees.push(tree);
                    scene.add(tree);
                }
                console.log(trees.length + " trees added to scene.");
            },
            undefined,
            function(error) {
                console.error('An error occurred while loading the pine_tree.glb model:', error);
            }
        );
    }
    function addGrass() {
        console.log("addGrass function called (Instanced Planar Grass).");
        if (!character || !forestMesh1) {
            console.warn("Character or terrain not ready in addGrass, deferring or skipping.");
            return;
        }

        const bladeGeometry = new THREE.PlaneGeometry(0.1, 1, 1, 4); // A single grass blade
        bladeGeometry.translate(0, 0.5, 0); // Pivot at base center

        const totalPatches = 50; // Number of large grass patches
        const instancesPerPatch = 150; // Number of blades per patch

        const dummy = new THREE.Object3D(); // Used for instance transforms

        for (let i = 0; i < totalPatches; i++) {
            const patchMesh = new THREE.InstancedMesh(bladeGeometry, leavesMaterial, instancesPerPatch);
            patchMesh.castShadow = false; // Individual blades don't cast shadows
            patchMesh.receiveShadow = true;

            const side = (i % 2 === 0) ? -1 : 1;
            const patchX = side * (5 + 0.5 + Math.random() * 10); // River edge (7), margin (2), spread (60)
            const patchZ = (character.position.z - forestLength / 2) + (Math.random() * forestLength);
            
            patchMesh.position.set(
                patchX,
                forestMesh1.position.y + 0.01, // Align patch with terrain base
                patchZ
            );
            scene.add(patchMesh);
            grasss.push(patchMesh); // Add the whole patch (InstancedMesh) to grasss array

            // Position and transform individual blades within this patch
            for (let j = 0; j < instancesPerPatch; j++) {
                dummy.position.set(
                    (Math.random() - 0.5) * 5,  // Spread blades within a 5x5 area for the patch
                    0, // Y is relative to patchMesh's position
                    (Math.random() - 0.5) * 5
                );
                dummy.scale.setScalar(0.5 + Math.random() * 0.5);
                dummy.rotation.y = Math.random() * Math.PI;
                dummy.updateMatrix();
                patchMesh.setMatrixAt(j, dummy.matrix);
            }
            patchMesh.instanceMatrix.needsUpdate = true;
        }
        console.log(grasss.length + " instanced grass patches added to scene.");
    }
    function addFishes() {
        console.log("addFishes function called.");
        // Ensure gltfLoader is initialized and available (now global)
        if (!gltfLoader) {
            console.error("addFishes: gltfLoader not initialized!");
            return;
        }
        if (!character) {
            console.warn("addFishes: Character not loaded yet, cannot determine initial Z position for fish. Skipping fish adding.");
            return;
        }

        gltfLoader.load( 
            '3Dmodels/fish.glb',
            function(gltf) {
                console.log("Fish model loaded.");
                for (let i = 0; i < 5; i++) { // Create 5 fishes
                    const fish = gltf.scene.clone();
                    const laneIndex = Math.floor(Math.random() * lanePositions.length);
                    fish.position.set(
                        lanePositions[laneIndex] + (Math.random() - 0.5) * 1.5, // Randomize slightly within lane
                        -0.7, // Initial Y position (underwater)
                        character.position.z - 30 - Math.random() * 100 // Spread them out behind character
                    );

                    fish.scale.set(0.2, 0.2, 0.2);
                    const randomRotationY = Math.random() * Math.PI * 2;
                    fish.rotation.set(0, randomRotationY, 0); // Initial rotation, jump animation will control X

                    fish.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            // node.receiveShadow = true; // Less important for fish
                        }
                    });
                    fishes.push(fish);
                    scene.add(fish);
                }
                console.log(fishes.length + " fishes added to scene.");
            },
            undefined,
            function(error) {
                console.error('An error occurred while loading the fish.glb model:', error);
            }
        );
    }

    function initParticleSystem() {
       particleSystemContainer = new THREE.Object3D();
       scene.add(particleSystemContainer);

       for (let i = 0; i < maxParticles; i++) {
           const spriteMaterial = new THREE.SpriteMaterial({
               map: splashTexture,
               blending: THREE.AdditiveBlending, 
               transparent: true,
               opacity: 0.8,
               sizeAttenuation: true
           });
           const particle = new THREE.Sprite(spriteMaterial);
           particle.visible = false;
           particle.scale.set(0.2, 0.2, 0.2); 
           particleSystemContainer.add(particle);
           particlePool.push({
               sprite: particle,
               isActive: false,
               life: 0,
               velocity: new THREE.Vector3(),
               gravity: 0.02, 
               initialScale: 0.2,
               maxScale: 0.5,
               scaleSpeed: 0.05
           });
       }
    }

    function emitSplash(position, count = 5, baseVelocity = 0.1) {
       let emittedCount = 0;
       for (let p of particlePool) {
           if (!p.isActive) {
               p.sprite.visible = true;
               p.isActive = true;
               p.life = 1.0 + Math.random() * 0.5; 
               p.sprite.position.copy(position);
               
               const angle = Math.random() * Math.PI * 2;
               const upwardSpeed = baseVelocity + Math.random() * baseVelocity;
               p.velocity.set(
                   Math.cos(angle) * baseVelocity * (0.5 + Math.random() * 0.5),
                   upwardSpeed,
                   Math.sin(angle) * baseVelocity * (0.5 + Math.random() * 0.5)
               );
               p.sprite.scale.set(p.initialScale, p.initialScale, p.initialScale);
               p.sprite.material.opacity = 0.8;

               emittedCount++;
               if (emittedCount >= count) break;
           }
       }
    }

    function updateParticles(delta) { 
       for (let p of particlePool) {
           if (p.isActive) {
               p.life -= delta * 2; 

               if (p.life <= 0) {
                   p.isActive = false;
                   p.sprite.visible = false;
               } else {
                   p.sprite.position.addScaledVector(p.velocity, delta * 20); 
                   p.velocity.y -= p.gravity * delta * 20; 

                   const lifeRatio = Math.max(0, p.life / (1.0 + 0.5)); 
                   p.sprite.material.opacity = Math.max(0, lifeRatio * 0.8);
                   
                   let currentScale = p.sprite.scale.x;
                   currentScale += p.scaleSpeed * delta * 10;
                   currentScale = Math.min(currentScale, p.maxScale);
                   p.sprite.scale.set(currentScale, currentScale, currentScale);
               }
           }
       }
    }

    let touchStartX = null;
    let touchEndX = null;
    function onTouchStart(event) {
        if (!animationLoopStarted || isPaused) return;
        touchStartX = event.touches[0].clientX;
    }
    function onTouchMove(event) {
        if (!animationLoopStarted || isPaused) return;
        touchEndX = event.touches[0].clientX;
    }
    function onTouchEnd() {
        if (!character || !gameReadyToStartByUser || !assetsLoaded || !gameInitialized || !animationLoopStarted || isPaused) return;
        if (touchStartX && touchEndX) {
            const deltaX = touchEndX - touchStartX;
            const turnAudio = document.getElementById('turnAudio');
            if (deltaX > 50) {
                if(turnAudio) turnAudio.play();
                targetLane = Math.min(2, currentLane + 1);
                targetCharacterRotationY = Math.PI - Math.PI / 8;
                targetCharacterRotationZ = -LEAN_ANGLE;
            } else if (deltaX < -50) {
                if(turnAudio) turnAudio.play();
                targetLane = Math.max(0, currentLane - 1);
                targetCharacterRotationY = Math.PI + Math.PI / 8;
                targetCharacterRotationZ = LEAN_ANGLE;
            }
            if (targetLane !== currentLane && character) {
                isTransitioning = true;
                
                const waterY = water1 ? water1.position.y : -0.15;
                let splashSideOffset = 0.6; 
                let splashPosition = new THREE.Vector3();

                if (targetLane < currentLane) { 
                    splashPosition.set(
                        character.position.x + splashSideOffset, 
                        waterY + 0.1, 
                        character.position.z 
                    );
                } else { 
                    splashPosition.set(
                        character.position.x - splashSideOffset, 
                        waterY + 0.1, 
                        character.position.z
                    );
                }
                emitSplash(splashPosition, 4 + Math.floor(Math.random() * 3), 0.04 + Math.random()*0.03);

                smoothTransition(character.position.x, lanePositions[targetLane], 100, () => {
                    currentLane = targetLane;
                    isTransitioning = false;
                });
            }
        }
        touchStartX = null; touchEndX = null;
    }

    function onKeyDown(event) {
        if (!character || !gameReadyToStartByUser || !assetsLoaded || !gameInitialized || !animationLoopStarted ) {
            if(event.key === 'p' && gameInitialized) togglePause();
            return;
        }
        if (isPaused && event.key !== 'p') return;

        const turnAudio = document.getElementById('turnAudio');
        if (isTransitioning && (event.key === 'ArrowLeft' || event.key === 'a' || event.key === 'ArrowRight' || event.key === 'd')) {
            if ((event.key === 'ArrowLeft' || event.key === 'a')) {
                targetCharacterRotationY = Math.PI + Math.PI / 8;
                targetCharacterRotationZ = LEAN_ANGLE;
            } else if ((event.key === 'ArrowRight' || event.key === 'd')) {
                targetCharacterRotationY = Math.PI - Math.PI / 8;
                targetCharacterRotationZ = -LEAN_ANGLE;
            }
            return;
        }
        if (isTransitioning) return;

        if (event.key === 'ArrowLeft' || event.key === 'a') {
            if(turnAudio) turnAudio.play();
            targetLane = Math.max(0, currentLane - 1);
            targetCharacterRotationY = Math.PI + Math.PI / 8;
            targetCharacterRotationZ = LEAN_ANGLE;
        } else if (event.key === 'ArrowRight' || event.key === 'd') {
            if(turnAudio) turnAudio.play();
            targetLane = Math.min(2, currentLane + 1);
            targetCharacterRotationY = Math.PI - Math.PI / 8;
            targetCharacterRotationZ = -LEAN_ANGLE;
        } else if (event.key === 'p') { togglePause(); }
        else { return; }

        if (targetLane !== currentLane && character) {
            isTransitioning = true;

            const waterY = water1 ? water1.position.y : -0.15;
            let splashSideOffset = 0.6; 
            let splashPosition = new THREE.Vector3();

            if (targetLane < currentLane) { 
                splashPosition.set(
                    character.position.x + splashSideOffset, 
                    waterY + 0.1, 
                    character.position.z
                );
            } else { 
                splashPosition.set(
                    character.position.x - splashSideOffset, 
                    waterY + 0.1, 
                    character.position.z
                );
            }
            emitSplash(splashPosition, 4 + Math.floor(Math.random() * 3), 0.04 + Math.random()*0.03);
            
            smoothTransition(character.position.x, lanePositions[targetLane], 100, () => {
                currentLane = targetLane; isTransitioning = false;
            });
        }
    }

    function smoothTransition(start, end, duration, callback) {
        const startTime = Date.now();
        function animateTransition() {
            const now = Date.now();
            const elapsed = now - startTime;
            const t = Math.min(elapsed / duration, 1);
            if (character) {
                character.position.x = start + (end - start) * t;
            }
            if (t < 1) {
                requestAnimationFrame(animateTransition);
            } else {
                if (callback) callback();
            }
        }
        requestAnimationFrame(animateTransition);
    }
    function getRandomQuoteNumber() { return Math.floor(Math.random() * 8) + 1; }

    function playRandomQuote() {
        if (RandomQuote && !RandomQuote.paused && RandomQuote.currentTime > 0 && RandomQuote.duration > 0 && RandomQuote.currentTime < RandomQuote.duration - 0.1) { // Check if ended or very close to end
            console.log("A quote is already playing.");
            return;
        }
        QuoteNumber = getRandomQuoteNumber();
        RandomQuote = document.getElementById('Quote' + QuoteNumber);
        if (RandomQuote) {
            console.log("Playing quote: ", QuoteNumber);
            RandomQuote.currentTime = 0; // Ensure it plays from the start
            RandomQuote.play().catch(e => console.warn("Quote audio play failed:", e));
        } else {
            console.warn("Could not find Quote audio element for number:", QuoteNumber);
        }
    }

    function triggerCameraShake(duration) { shakeDuration = duration; shakeTime = 0;}
    function applyCameraShake() {
        if (shakeTime < shakeDuration && camera) {
            const shakeAmount = 0.08;
            camera.position.x += (Math.random() - 0.5) * shakeAmount;
            camera.position.y += (Math.random() - 0.5) * shakeAmount;
            shakeTime += 1/fps;
        }
    }
    function updatePoints() {
        if(isPaused || !animationLoopStarted) return;
        totalPoints += 1;
        const totalPointsEl = document.getElementById('totalPoints');
        if(totalPointsEl) totalPointsEl.innerText = totalPoints;
        IncreaseSpeed();
    }
    function IncreaseSpeed() {
        if (totalPoints % 1000 === 0 && totalPoints > 0) {
            speed = Math.min(speed + 0.02, 0.5);
            console.log("Speed increased to:", speed);
        }
    }

    function animateWater() {
        if (water1 && water1.material.uniforms && water1.material.uniforms['time']) {
            water1.material.uniforms['time'].value += 1.0 / 60.0;
        }
        if (water2 && water2.material.uniforms && water2.material.uniforms['time']) {
            water2.material.uniforms['time'].value += 1.0 / 60.0;
        }
    }

    function checkCollisions() {
        if (!character || !gameInitialized || isPaused || !animationLoopStarted) return;

        const collisionAudio = document.getElementById('collisionAudio');
        const treasureAudio = document.getElementById('treasureAudio');
        const chancesEl = document.getElementById('chances');
        const treasuresFoundEl = document.getElementById('treasuresFound');
        const collisionsDiv = document.getElementById('collisions');

        // Obstacle collisions
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obstacle = obstacles[i];
            if (character.position.distanceTo(obstacle.position) < 0.65) {
                console.log("Collision with obstacle!");
                if(collisionAudio) collisionAudio.play();

                chances--;
                if(chancesEl) chancesEl.innerText = chances;

                if(collisionsDiv){
                    if (chances === 2) collisionsDiv.style.backgroundColor = 'rgba(236,255,0,0.5)';
                    else if (chances === 1) collisionsDiv.style.backgroundColor = 'rgba(255,125,0,0.5)';
                    else if (chances <= 0) collisionsDiv.style.backgroundColor = 'rgba(255,0,0,0.5)';
                    else collisionsDiv.style.backgroundColor = 'rgba(0,255,0,0.5)';
                }

                obstacle.position.z = character.position.z - 150 - Math.random() * 50;
                obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];

                triggerCameraShake(0.5);

                if (chances <= 0) {
                    console.log("Game Over!");
                    const backgroundAudio = document.getElementById('backgroundAudio');
                    if(backgroundAudio) backgroundAudio.pause();
                    alert('Game Over!\nScore: ' + totalPoints + '\nTotal nuggets: ' + treasures + '\nPress OK to restart.');
                    window.location.reload();
                    return;
                }
            }
        }

        // Nugget collisions
        for (let i = nuggets.length - 1; i >= 0; i--) {
            const nugget = nuggets[i];
            if (character.position.distanceTo(nugget.position) < 0.7) { // Adjusted nugget collision radius if needed due to scale
                console.log("Collected nugget!");
                if(treasureAudio) treasureAudio.play();
                playRandomQuote();

                treasures++;
                chances++;

                if(treasuresFoundEl) treasuresFoundEl.innerText = treasures;
                if(chancesEl) chancesEl.innerText = chances;

                if(collisionsDiv){
                    if (chances === 2) collisionsDiv.style.backgroundColor = 'rgba(236,255,0,0.5)';
                    else if (chances === 1) collisionsDiv.style.backgroundColor = 'rgba(255,125,0,0.5)';
                    else if (chances <= 0) collisionsDiv.style.backgroundColor = 'rgba(255,0,0,0.5)';
                    else collisionsDiv.style.backgroundColor = 'rgba(0,255,0,0.5)';
                }
                nugget.position.z = character.position.z - 150 - Math.random() * 50;
                nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
            }
        }
    }

    function init() {
        console.log("init function started.");
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000000);
        camera.position.set(0, 2.0, 4.0);
        camera.lookAt(0, 0.5, 0);
        console.log("Initial Camera Position:", camera.position);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5;
        document.body.appendChild(renderer.domElement);

        initSky();

        fillLight = new THREE.HemisphereLight(0x8dc1de, 0x00668d, 1.5);
        scene.add(fillLight);
        directionalLight = new THREE.DirectionalLight(0xffffff, 3.0);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);
        scene.add(directionalLight.target);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        renderer.shadowMap.enabled = true;

        console.log("Attempting to add terrain planes.");
        if (heightMapImage.image && HeightMapTexture && heightMapImage.image.complete && heightMapImage.image.naturalHeight !== 0) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const context = canvas.getContext('2d');
            context.drawImage(heightMapImage.image, 0, 0, size, size);
            const heightData = context.getImageData(0, 0, size, size).data;
            const planeGeometry = new THREE.PlaneGeometry(300, forestLength, size - 1, size - 1);
            for (let i = 0; i < planeGeometry.attributes.position.count; i++) {
                const xVal = i % size; const yVal = Math.floor(i / size);
                const height = heightData[(yVal * size + xVal) * 4] / 255 * 10;
                planeGeometry.attributes.position.setZ(i, height);
            }
            planeGeometry.computeVertexNormals();
            const planeMaterial = new THREE.MeshStandardMaterial({ map: HeightMapTexture });

            forestMesh1 = new THREE.Mesh(planeGeometry, planeMaterial);
            forestMesh1.rotation.x = -Math.PI / 2;
            forestMesh1.position.y = -0.5;
            forestMesh1.position.z = -forestLength / 2 + 50;
            forestMesh1.receiveShadow = true;
            scene.add(forestMesh1);

            forestMesh2 = new THREE.Mesh(planeGeometry.clone(), planeMaterial.clone());
            forestMesh2.rotation.x = -Math.PI / 2;
            forestMesh2.position.y = -0.5;
            forestMesh2.position.z = forestMesh1.position.z - forestLength;
            forestMesh2.receiveShadow = true;
            scene.add(forestMesh2);
            console.log("Dual terrain planes added.");
        } else {
            console.warn("Terrain textures not ready, using placeholder flat terrain.");
            const placeholderGeo = new THREE.PlaneGeometry(300, forestLength);
            const placeholderMat = new THREE.MeshStandardMaterial({ color: 0x335522 });
            forestMesh1 = new THREE.Mesh(placeholderGeo, placeholderMat);
            forestMesh1.rotation.x = -Math.PI / 2; forestMesh1.position.y = -0.5;
            forestMesh1.position.z = -forestLength/2 + 50; scene.add(forestMesh1);
            forestMesh2 = new THREE.Mesh(placeholderGeo.clone(), placeholderMat.clone());
            forestMesh2.rotation.x = -Math.PI/2; forestMesh2.position.y = -0.5;
            forestMesh2.position.z = forestMesh1.position.z - forestLength; scene.add(forestMesh2);
            console.log("Placeholder terrain planes added.");
        }

        console.log("Attempting to add water planes. Water Normals loaded:", waterNormals && waterNormals.image && waterNormals.image.complete);
        if (Water && waterNormals && waterNormals.image && waterNormals.image.complete && waterNormals.image.naturalHeight !== 0) {
            const waterPlaneGeometry = new THREE.PlaneGeometry(10, waterLength, 10, 50);

            // Apply Vertex Displacement for uneven river sides (Increased factor)
            const widthSegments = waterPlaneGeometry.parameters.widthSegments; // Should be 10
            const depthSegments = waterPlaneGeometry.parameters.depthSegments; // Should be 50


            let sunDir = new THREE.Vector3(0,1,0);
            if (sky && sky.material.uniforms.sunPosition) {
                sunDir.copy(sky.material.uniforms.sunPosition.value);
                console.log("Water using sunDirection from sky:", sunDir);
            } else if (directionalLight) {
                sunDir.copy(directionalLight.position).normalize();
                console.log("Water using sunDirection from directionalLight:", sunDir);
            } else {
                console.warn("Water: Neither sky nor directionalLight sunPosition available, using default sunDir.");
            }

            const waterOptions = {
                textureWidth: 512, textureHeight: 512, waterNormals: waterNormals,
                sunDirection: sunDir, sunColor: 0xffffff,
                waterColor: 0x00ccff, // Bright cyan for testing
                distortionScale: 2.0,
                fog: false,
                alpha: 1.0, // Fully opaque for testing
                scale: 4
            };
            water1 = new Water(waterPlaneGeometry, waterOptions);
            water1.rotation.x = -Math.PI / 2;
            water1.position.y = -0.15; // Raised water level for testing
            water1.position.z = -waterLength / 2 + 50;
            scene.add(water1);

            water2 = new Water(waterPlaneGeometry.clone(), waterOptions);
            water2.rotation.x = -Math.PI / 2;
            water2.position.y = -0.15; // Raised water level for testing
            water2.position.z = water1.position.z - waterLength;
            scene.add(water2);
            console.log("Dual water planes added at Y:", water1.position.y);

            const bankMaterial = new THREE.MeshStandardMaterial({ color: 0x6B4423, side: THREE.DoubleSide }); 

            // For water1
            const leftBank1Geometry = new THREE.PlaneGeometry(2, waterLength, 5, 20);
            const rightBank1Geometry = new THREE.PlaneGeometry(2, waterLength, 5, 20);
            modifyBankVertices(leftBank1Geometry, true); // true for left bank
            modifyBankVertices(rightBank1Geometry, false); // false for right bank
            const leftBank1 = new THREE.Mesh(leftBank1Geometry, bankMaterial);
            const rightBank1 = new THREE.Mesh(rightBank1Geometry, bankMaterial);
            leftBank1.rotation.x = -Math.PI / 2;
            leftBank1.position.set(-6, water1.position.y - 0.05, water1.position.z);
            rightBank1.rotation.x = -Math.PI / 2;
            rightBank1.position.set(6, water1.position.y - 0.05, water1.position.z);
            leftBank1.receiveShadow = true; rightBank1.receiveShadow = true;
            scene.add(leftBank1); scene.add(rightBank1);
            leftBankMeshes.push(leftBank1); rightBankMeshes.push(rightBank1);

            // For water2
            const leftBank2Geometry = new THREE.PlaneGeometry(2, waterLength, 5, 20);
            const rightBank2Geometry = new THREE.PlaneGeometry(2, waterLength, 5, 20);
            modifyBankVertices(leftBank2Geometry, true);
            modifyBankVertices(rightBank2Geometry, false);
            const leftBank2 = new THREE.Mesh(leftBank2Geometry, bankMaterial);
            const rightBank2 = new THREE.Mesh(rightBank2Geometry, bankMaterial);
            leftBank2.rotation.x = -Math.PI / 2;
            leftBank2.position.set(-6, water2.position.y - 0.05, water2.position.z);
            rightBank2.rotation.x = -Math.PI / 2;
            rightBank2.position.set(6, water2.position.y - 0.05, water2.position.z);
            leftBank2.receiveShadow = true; rightBank2.receiveShadow = true;
            scene.add(leftBank2); scene.add(rightBank2);
            leftBankMeshes.push(leftBank2); rightBankMeshes.push(rightBank2);
        } else {
            let logMessage = "Water not created. Reasons: ";
            if (!Water) logMessage += "Water class not found. ";
            if (!waterNormals) logMessage += "waterNormals variable not defined. ";
            if (waterNormals && !waterNormals.image) logMessage += "waterNormals.image not defined. ";
            if (waterNormals && waterNormals.image && !waterNormals.image.complete) logMessage += "waterNormals.image not complete. ";
            if (waterNormals && waterNormals.image && waterNormals.image.complete && waterNormals.image.naturalHeight === 0) logMessage += "waterNormals.image has zero height. ";
            console.warn(logMessage);
        }

        // Initialize global GLTFLoader
        const dracoLoader = new DRACOLoader(manager);
        dracoLoader.setDecoderPath( 'three/addons/loaders/draco/' );
        gltfLoader = new GLTFLoader(manager); // Assign to global gltfLoader
        gltfLoader.setDRACOLoader( dracoLoader );
            
        // Call addCharacter. Trees, grass, fish will be called from its callback.
        addCharacter(); 

        initParticleSystem(); // Initialize particle system

        gltfLoader.load('3Dmodels/rock.glb', (gltf) => { // Uses global gltfLoader
            console.log("Rock model loaded.");
            for (let i = 0; i < 15; i++) {
                const obstacle = gltf.scene.clone();
                const baseScale = 0.08 + Math.random() * 0.12; // Rocks will be smaller on average: 0.08 to 0.2
                const yScale = baseScale * (0.7 + Math.random() * 0.6); // Y scale can be 70% to 130% of baseScale
                obstacle.scale.set(baseScale, yScale, baseScale);
                obstacle.rotation.y = Math.random() * Math.PI * 2;
                obstacle.position.set(lanePositions[Math.floor(Math.random() * 3)], -0.15, -20 - i * 20); // Lowered rocks
                obstacle.traverse(node => { if (node.isMesh) node.castShadow = true; });
                obstacles.push(obstacle);
                scene.add(obstacle);
            }
        }, undefined, (error)=>console.error("Error loading rock.glb", error));

        gltfLoader.load('3Dmodels/gold_nugget.glb', (gltf) => {
            console.log("Gold nugget model loaded.");
            for (let i = 0; i < 10; i++) {
                const nugget = gltf.scene.clone();
                const scale = 5.0; // INCREASED NUGGET SCALE SIGNIFICANTLY
                nugget.scale.set(scale, scale, scale);
                nugget.position.set(
                    lanePositions[Math.floor(Math.random() * 3)],
                    0.1, // Adjusted Y for nuggets
                    -25 - i * 30 - Math.random() * 10
                );
                console.log("Nugget ["+i+"]: added at X:", nugget.position.x, "Y:", nugget.position.y, "Z:", nugget.position.z);
                nugget.traverse(node => { if (node.isMesh) node.castShadow = true; });
                nuggets.push(nugget);
                scene.add(nugget);
            }
        }, undefined, (error) => console.error("Error loading gold_nugget.glb", error));

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('touchstart', onTouchStart);
        document.addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);
        console.log("init function completed.");
    }

    function addCharacter(){ // Now uses the global gltfLoader
        console.log("addCharacter function called.");
        // const dracoLoader = new DRACOLoader(manager); // Removed, use global
        // dracoLoader.setDecoderPath( 'three/addons/loaders/draco/' ); // Removed
        // const loader4 = new GLTFLoader(manager); // Removed, use global
        // loader4.setDRACOLoader( dracoLoader ); // Removed
        gltfLoader.load('3Dmodels/Lumberjack_on_a_log.glb', function (gltf) { // Use global gltfLoader
                console.log("Lumberjack_on_a_log.glb loaded successfully in addCharacter.");
                character = gltf.scene;
                character.scale.set(0.4, 0.4, 0.4);
                const box = new THREE.Box3().setFromObject(character);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                characterBaseYOffset = -(center.y - size.y / 2) - SUBMERGE_AMOUNT;
                character.position.set(lanePositions[currentLane], characterBaseYOffset, -2);
                character.rotation.y = Math.PI;
                character.traverse(node => { if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; }});
                scene.add(character);
                targetLane = currentLane; // Initialize targetLane based on currentLane
                console.log("Character added to scene. BaseYOffset:", characterBaseYOffset, "Final Y:", character.position.y);

                // NOW, CALL DEPENDENT FUNCTIONS
                console.log("Character loaded, now calling addTrees, addGrass, addFishes.");
                if (forestMesh1 && forestMesh2) { // Ensure terrain is ready
                    addTrees();
                    addGrass();
                } else {
                    console.error("Terrain meshes not ready when trying to add trees/grass after character load.");
                }
                addFishes(); // Fishes depend on character position primarily
            },
            xhr => console.log('Lumberjack model ' + (xhr.loaded / xhr.total * 100) + '% loaded'),
            err => console.error('Error loading Lumberjack_on_a_log.glb:', err)
        );
     }
    function updateCamera() {
        if (!character || !camera) return;
        const desiredX = character.position.x;
        const desiredY = character.position.y + 1.2;
        const desiredZ = character.position.z + 1.7;
        camera.position.x = desiredX;
        camera.position.y = desiredY;
        camera.position.z = desiredZ;
    }

    function animate(currentTime) {
        requestAnimationFrame(animate);
        if (!animationLoopStarted || isPaused) {
            if (isPaused && totalPoints < 10 && document.getElementById('countdown') && document.getElementById('countdown').style.display === 'block') {
                 if(renderer && scene && camera) renderer.render(scene, camera);
            }
            return;
        }
        if (firstAnimateCall) { console.log("animate running."); firstAnimateCall = false; }
        if (!character) { if(renderer && scene && camera) renderer.render(scene, camera); return; }

        character.rotation.y += (targetCharacterRotationY - character.rotation.y) * rotationSpeed;
        character.rotation.z += (targetCharacterRotationZ - character.rotation.z) * rotationSpeed;
        if (!isTransitioning && currentLane === targetLane) {
            const defaultRotationY = Math.PI;
            if (Math.abs(character.rotation.y - defaultRotationY) < rotationSpeed * 0.01 ) character.rotation.y = defaultRotationY;
            targetCharacterRotationY = defaultRotationY;
            if (Math.abs(character.rotation.z) < rotationSpeed * 0.01) character.rotation.z = 0;
            targetCharacterRotationZ = 0;
        }

        const delta = currentTime - lastTime;
        if (delta >= interval) {
            lastTime = currentTime - (delta % interval);
            animateWater();

            if (forestMesh1 && forestMesh2 && character) {
                forestMesh1.position.z += speed;
                forestMesh2.position.z += speed;
                if (forestMesh1.position.z > character.position.z + forestLength / 2 + 20) {
                    forestMesh1.position.z = forestMesh2.position.z - forestLength + speed;
                }
                if (forestMesh2.position.z > character.position.z + forestLength / 2 + 20) {
                    forestMesh2.position.z = forestMesh1.position.z - forestLength + speed;
                }
            }
            if (water1 && water2 && character) {
                water1.position.z += speed;
                water2.position.z += speed;
                if (water1.position.z > character.position.z + waterLength / 2 + 20) {
                    water1.position.z = water2.position.z - waterLength + speed;
                }
                if (water2.position.z > character.position.z + waterLength / 2 + 20) {
                    water2.position.z = water1.position.z - waterLength + speed;
                }
            }

            // Update bank positions to follow water
            if (leftBankMeshes.length >= 2 && rightBankMeshes.length >=2 && water1 && water2) {
                leftBankMeshes[0].position.z = water1.position.z;
                rightBankMeshes[0].position.z = water1.position.z;
                leftBankMeshes[1].position.z = water2.position.z;
                rightBankMeshes[1].position.z = water2.position.z;
            }

            for (let obstacle of obstacles) {
                 obstacle.position.z += speed;
                if (character && obstacle.position.z > character.position.z + 20 ) {
                    obstacle.position.z = (character.position.z - 130) - Math.random() * 50;
                    obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];
                } else if (!character && obstacle.position.z > 20) {
                     obstacle.position.z = -130 - Math.random() * 50;
                     obstacle.position.x = lanePositions[Math.floor(Math.random() * 3)];
                }
            }
            for (let nugget of nuggets) {
                nugget.position.z += speed;
                if (character && nugget.position.z > character.position.z + 20) {
                    nugget.position.z = (character.position.z - 130) - Math.random() * 100;
                    nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
                } else if (!character && nugget.position.z > 20) {
                    nugget.position.z = -130 - Math.random() * 100;
                    nugget.position.x = lanePositions[Math.floor(Math.random() * 3)];
                }
            }

            // Fish animation
            for (let fish of fishes) {
                const fishJumpHeight = 0.8; 
                const fishJumpDuration = 0.6; 
                const fishJumpFrequency = 0.02; 

                fish.position.z += speed; 

                if (fish.userData === undefined) fish.userData = {};
                fish.userData.previousY = fish.userData.previousY === undefined ? (water1 ? water1.position.y : -0.15) : fish.userData.previousY;
                fish.userData.jumpTime = (fish.userData.jumpTime || 0) + fishJumpFrequency;

                fish.position.y = -0.7 + Math.max(0, Math.sin(fish.userData.jumpTime * Math.PI / fishJumpDuration) * fishJumpHeight);

                const rotationAngle = Math.sin(fish.userData.jumpTime * Math.PI / fishJumpDuration) * Math.PI;
                fish.rotation.x = rotationAngle;
                const waterSurfaceYForFishSplash = water1 ? water1.position.y : -0.15;
                // Check for exiting water
                if (fish.userData.previousY <= waterSurfaceYForFishSplash && fish.position.y > waterSurfaceYForFishSplash) {
                    emitSplash(new THREE.Vector3(fish.position.x, waterSurfaceYForFishSplash + 0.05, fish.position.z), 2 + Math.floor(Math.random() * 2), 0.02 + Math.random()*0.02);
                }
                // Check for re-entering water
                else if (fish.userData.previousY > waterSurfaceYForFishSplash && fish.position.y <= waterSurfaceYForFishSplash) {
                    emitSplash(new THREE.Vector3(fish.position.x, waterSurfaceYForFishSplash + 0.05, fish.position.z), 2 + Math.floor(Math.random() * 2), 0.02 + Math.random()*0.02);
                }
                fish.userData.previousY = fish.position.y;

                if (character && fish.position.z > character.position.z + 20) {
                    const laneIndex = Math.floor(Math.random() * lanePositions.length);
                    fish.position.set(
                        lanePositions[laneIndex] + (Math.random() - 0.5) * 1.5,
                        -0.7, 
                        character.position.z - 130 - Math.random() * 100 
                    );
                    fish.userData.jumpTime = 0;
                    fish.rotation.x = 0; 
                } else if (!character && fish.position.z > 20) { 
                     fish.position.set(
                        lanePositions[Math.floor(Math.random() * 3)] + (Math.random() - 0.5) * 1.5,
                        -0.7,
                        -130 - Math.random() * 100
                    );
                    fish.userData.jumpTime = 0;
                    fish.rotation.x = 0;
                }
            }

            // Tree recycling
            for (let tree of trees) {
                tree.position.z += speed; // Trees move with the terrain/water

                // If a tree moves past the character's view plus half a forest segment, recycle it
                if (character && tree.position.z > character.position.z + (forestLength / 2) + 20) {
                    const side = (Math.random() < 0.5) ? -1 : 1;
                    tree.position.x = side * (7 + 5 + Math.random() * 60);
                    // Recycle to the back, behind the second terrain segment, relative to character.
                    tree.position.z = character.position.z - (forestLength / 2) - Math.random() * (forestLength / 2);

                    const randomScaleBase = 1.5 + Math.random() * 1.0;
                    const randomScaleY = randomScaleBase * (1.0 + Math.random() * 1.0);
                    tree.scale.set(randomScaleBase, randomScaleY, randomScaleBase);
                    tree.rotation.y = Math.random() * Math.PI * 2;
                } else if (!character && tree.position.z > (forestLength / 2) + 20) { // Fallback if character not loaded
                    const side = (Math.random() < 0.5) ? -1 : 1;
                    tree.position.x = side * (7 + 5 + Math.random() * 60);
                    tree.position.z = -(forestLength / 2) - Math.random() * (forestLength/2);
                }
            }

            // Grass recycling & animation update
            if (leavesMaterial && leavesMaterial.uniforms && leavesMaterial.uniforms.time) {
                leavesMaterial.uniforms.time.value = clock.getElapsedTime();
            }

            for (let grassPatch of grasss) { // Now grasss contains InstancedMesh objects
                grassPatch.position.z += speed;

                if (character && grassPatch.position.z > character.position.z + (forestLength / 2) + 20) {
                    const side = (Math.random() < 0.5) ? -1 : 1;
                    grassPatch.position.x = side * (7 + 2 + Math.random() * 60); // Matches new addGrass
                    grassPatch.position.z = character.position.z - (forestLength / 2) - Math.random() * (forestLength / 2);
                    // Individual blade matrices within the patch are not re-randomized upon recycling the patch itself.
                } else if (!character && grassPatch.position.z > (forestLength / 2) + 20) { // Fallback
                    const side = (Math.random() < 0.5) ? -1 : 1;
                    grassPatch.position.x = side * (7 + 2 + Math.random() * 60); // Matches new addGrass
                    grassPatch.position.z = -(forestLength / 2) - Math.random() * (forestLength / 2);
                }
            }

            updateParticles(1/fps); // Update all active particles

            // Rock splash triggering logic
            const waterY = water1 ? water1.position.y : -0.15; 

            for (let obstacle of obstacles) {
                if (character && Math.abs(obstacle.position.z - character.position.z) < 30 && obstacle.position.z < character.position.z) {
                    if (Math.abs(obstacle.position.y - waterY) < 0.2) { 
                        obstacle.userData = obstacle.userData || {};
                        const now = performance.now();
                        if (!obstacle.userData.lastSplashTime || (now - obstacle.userData.lastSplashTime > 500 + Math.random() * 500)) { 
                            const splashPos = new THREE.Vector3(obstacle.position.x, waterY + 0.1, obstacle.position.z - 0.1);
                            emitSplash(splashPos, 3 + Math.floor(Math.random() * 3), 0.05 + Math.random()*0.05); 
                            obstacle.userData.lastSplashTime = now;
                       }
                   }
               }
            }

            // Continuous forward splash (wake)
            if (character && speed > 0.05 && animationLoopStarted && !isPaused) { 
                character.userData = character.userData || {};
                const now = performance.now();
                const wakeCooldown = 150 + Math.random() * 100; 

                if (!character.userData.lastWakeSplashTime || (now - character.userData.lastWakeSplashTime > wakeCooldown)) {
                    const waterYWake = water1 ? water1.position.y : -0.15;
                    const frontSplashPosition = new THREE.Vector3(
                        character.position.x, 
                        waterYWake + 0.05, 
                        character.position.z - 0.5 
                    );
                    emitSplash(frontSplashPosition, 1 + Math.floor(Math.random() * 2), 0.02 + Math.random()*0.02); 

                    character.userData.lastWakeSplashTime = now;
                }
            }

            updatePoints();
            updateCamera();
            if (character && camera && directionalLight) {
                directionalLight.position.set(camera.position.x + 1.5, camera.position.y + 3, camera.position.z + 0.5); // Position light slightly above and behind camera
                directionalLight.target.position.copy(character.position);
                directionalLight.target.updateMatrixWorld(); // Important for target changes
            }
            checkCollisions();
            applyCameraShake();
            if(renderer && scene && camera) renderer.render(scene, camera);
            else console.error("Render call skipped: renderer, scene or camera missing.");

            const Announcement = document.getElementById('Announcement');
            const dashboard = document.getElementById('dashboard');
            const pauseButton = document.getElementById('pauseButton');
            const countdown = document.getElementById('countdown');

            if(totalPoints === 10 && Announcement && Announcement.style.display !== 'none' && !window.countdownStarted){
                window.countdownStarted = true;
                Announcement.style.display = 'none';
                if (!isPaused) togglePause();
                else {
                    if(dashboard) dashboard.style.display = 'block';
                    if(pauseButton) pauseButton.style.display = 'block';
                }
                if(countdown) countdown.style.display = 'block';
                let countdownValue = 3;
                if(countdown) countdown.innerText = countdownValue;

                if (currentCountdownInterval) clearInterval(currentCountdownInterval);
                currentCountdownInterval = setInterval(() => {
                    countdownValue -= 1;
                    if(countdown) {
                        if (countdownValue > 0) {
                            countdown.innerText = countdownValue;
                        } else {
                            clearInterval(currentCountdownInterval);
                            currentCountdownInterval = null;
                            countdown.style.display = 'none';
                            if(isPaused) togglePause();
                            const backgroundAudio = document.getElementById('backgroundAudio');
                            if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed post-countdown:", e));
                        }
                    } else { clearInterval(currentCountdownInterval); currentCountdownInterval = null;}
                }, 1000);
            }
        }
    }

    function initiateAnimationLoop() {
        console.log("initiateAnimationLoop called.");
        console.log(`Flags before starting: gameReadyToStartByUser: ${gameReadyToStartByUser}, assetsLoaded: ${assetsLoaded}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);

        if (!assetsLoaded || !gameInitialized) {
            console.error("Attempted to initiate animation loop, but assets or game not initialized!");
            return;
        }
        if (animationLoopStarted) {
            console.warn("Animation loop already initiated. Ignoring call.");
            if (isPaused) togglePause();
            return;
        }

        const backgroundAudio = document.getElementById('backgroundAudio');
        if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed in initiateAnimationLoop:", e));

        let needsInitialPauseForCountdown = (totalPoints < 10);

        if (needsInitialPauseForCountdown && !isPaused) {
            console.log("initiateAnimationLoop: Initializing first pause for countdown.");
            togglePause();
        } else if (isPaused && !needsInitialPauseForCountdown) {
            console.log("initiateAnimationLoop: Game was paused by user, toggling to resume.");
            togglePause();
        } else if (isPaused && needsInitialPauseForCountdown) {
            console.log("initiateAnimationLoop: Already paused, likely for countdown.");
        }

        firstAnimateCall = true;
        animationLoopStarted = true;

        animate();
        console.log("Animation loop requested. animationLoopStarted set to true.");
    }

    window.startGame = function() {
        console.log("startGame function called by button click.");
        const announcementDiv = document.getElementById('Announcement');
        if(announcementDiv) announcementDiv.style.display = 'none';

        const dashboard = document.getElementById('dashboard');
        const pauseButton = document.getElementById('pauseButton');
        if(dashboard) dashboard.style.display = 'block';
        if(pauseButton) pauseButton.style.display = 'block';

        gameReadyToStartByUser = true;
        console.log(`startGame: Flags - gameReadyToStartByUser: ${gameReadyToStartByUser}, assetsLoaded: ${assetsLoaded}, gameInitialized: ${gameInitialized}, animationLoopStarted: ${animationLoopStarted}`);

        if (assetsLoaded && gameInitialized && !animationLoopStarted) {
            console.log("startGame: Conditions met to start animation.");
            initiateAnimationLoop();
        } else if (assetsLoaded && gameInitialized && animationLoopStarted) {
            console.log("startGame: Animation loop already started.");
            if(isPaused) {
                console.log("startGame: Was paused, toggling pause to resume.");
                togglePause();
            }
        } else {
            console.log("startGame: Conditions NOT met to start animation immediately.");
            if (!assetsLoaded) console.log("Reason: Assets not yet loaded.");
            if (!gameInitialized) console.log("Reason: Game not yet initialized.");
        }
    }

    function togglePause() {
        isPaused = !isPaused;
        const backgroundAudio = document.getElementById('backgroundAudio');
        const pauseButton = document.getElementById('pauseButton');
        const countdown = document.getElementById('countdown');
        const announcementDiv = document.getElementById('Announcement');

        if (!isPaused) {
            lastTime = performance.now();
            if(backgroundAudio) backgroundAudio.play().catch(e => console.warn("Audio play failed on resume:", e));
            if(pauseButton) pauseButton.innerText = "Pause";
            if(countdown) countdown.style.display = "none";
            if (gameInitialized && assetsLoaded && gameReadyToStartByUser && !animationLoopStarted) {
                console.log("togglePause (resuming): Conditions met, ensuring animation loop starts.");
                initiateAnimationLoop();
            } else if (!animationLoopStarted) {
                 console.log("togglePause (resuming): Animation loop not started, but conditions might not be fully met yet or it's handled by initiateAnimationLoop.");
            }
        } else {
            if(backgroundAudio) backgroundAudio.pause();
            if(pauseButton) pauseButton.innerText = "Resume";
            if(countdown && announcementDiv && (totalPoints >= 10 || (totalPoints < 10 && announcementDiv.style.display === 'none') ) ){
                 countdown.style.display = "block";
                 countdown.style.cursor = "pointer";
                 countdown.innerText = "Game Paused";
                 countdown.onclick = togglePause;
            } else if (countdown && totalPoints === 0 && !gameReadyToStartByUser){
                 // This is initial auto-pause for countdown, text set by interval in animate
            }
        }
        console.log("Game paused state:", isPaused);
     }

    document.getElementById('pauseButton').addEventListener('click', togglePause);
    console.log("End of script module parsing. Event listeners attached. Waiting for asset loading or user interaction.");

</script>


<div id="dashboard">
    <div id="totalpointscontained"><span id="totalPoints">0</span></div>
    <div id="collisions" style="vertical-align: middle;"><span id="chances">3</span></div>
    <div id="nuggetscontained">
        <img src="media/goldnugget.png" style="width:3vw; vertical-align: middle;">
        <span id="treasuresFound" style="color:black; vertical-align: middle;">0</span>
    </div>
</div>

<div id="pauseButton">Pause</div>
<div id="countdown"></div>

<div id="Announcement">
    <img src="media/ridingonittitle.jpeg" style="max-height:50%;">
    <h1>I'm Riding on it!</h1>
    <div onclick="startGame()" style="padding:20px; background-color:gray; border-radius:5px;">
        <span id="Menu" style="font-size:3vw; color:black; cursor:pointer;">Click here to Start the game</span>
    </div>
    <div style="margin-top:10px; font-size:1.5vw;">Let's ride on the river while avoiding the rocks, and collecting the gold nuggets!</div>
    <div><a href="light.html">Click here if you need lower graphic for better game rending.</a></div>
</div>
</body>
</html>
